# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
# Christopher Meng <cickumqt@gmail.com>, 2013
# Leah Liu <lliu@redhat.com>, 2008, 2009, 2010, 2012
# Tommy He <lovenemesis@gmail.com>, 2012-2013
# Tony Fu <tfu@redhat.com>, 2006
# Wei Liu <LLIU@REDHAT.COM>, 2013
# Xi Huang <xhuang@redhat.com>, 2006
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-01-15 16:34+0100\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"PO-Revision-Date: 2013-11-19 07:27-0500\n"
"Last-Translator: Tommy He <lovenemesis@gmail.com>\n"
"Language-Team: Chinese (China) (http://www.transifex.com/projects/p/fedora/"
"language/zh_CN/)\n"
"Language: zh-CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Zanata 3.7.3\n"

#: ../src/allow_anon_write.py:27
msgid ""
"\n"
"    SELinux policy is preventing an httpd script from writing to a public\n"
"    directory.\n"
"    "
msgstr "\n"
"    SELinux 策略正在阻止一个 httpd 脚本写入一个公共\n"
"    目录。\n"
"    "

#: ../src/allow_anon_write.py:32
msgid ""
"\n"
"    SELinux policy is preventing an httpd script from writing to a public\n"
"    directory.  If httpd is not setup to write to public directories, this\n"
"    could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 策略正在阻止 httpd 脚本写入一个公共目录。\n"
"    如果没有将 httpd 设置为可写入公共目录，这可能是一个入侵尝试信号。\n"
"      "

#: ../src/allow_anon_write.py:38
msgid ""
"\n"
"    If httpd scripts should be allowed to write to public directories you "
"need to turn on the $BOOLEAN boolean and change the file context of the "
"public directory to public_content_rw_t.  Read the httpd_selinux\n"
"    man page for further information:\n"
"    \"setsebool -P $BOOLEAN=1; chcon -t public_content_rw_t <path>\"\n"
"    You must also change the default file context labeling files on the "
"system in order to preserve public directory labeling even on a full relabel."
"  \"semanage fcontext -a -t public_content_rw_t <path>\"\n"
"    "
msgstr ""
"\n"
"    如果需要让 httpd 脚本写入公共目录，您需要开启 $BOOLEAN 布尔值并且将公共目录的文件上下文改为 "
"public_content_rw_t。  阅读 httpd_selinux \n"
"    的 man page 获得更多信息：\n"
"    \"setsebool -P $BOOLEAN=1; chcon -t public_content_rw_t <路径>\"\n"
"    您还必须更改系统中文件的默认文件上下文以便在重新标记时仍可保留公共目录标记。 \"semanage fcontext -a -t "
"public_content_rw_t <路径>\"\n"
"        "

#: ../src/allow_anon_write.py:44
msgid ""
"you want to allow $SOURCE_PATH to be able to write to shared public content"
msgstr "您要允许 $SOURCE_PATH 写入共享公共内容"

#: ../src/allow_anon_write.py:45
msgid ""
"you need to change the label on $TARGET_PATH to public_content_rw_t, and "
"potentially turn on the allow_httpd_sys_script_anon_write boolean."
msgstr ""
"您需要在 $TARGET_PATH 中将标签改为 public_content_rw_t，并可能打开 "
"allow_httpd_sys_script_anon_write 布尔。"

#: ../src/allow_execheap.py:27
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from changing the access\n"
"    protection of memory on the heap.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE 修改堆上\n"
"    的内存访问保护.\n"
"    "

#: ../src/allow_execheap.py:32
msgid ""
"\n"
"    The $SOURCE application attempted to change the access protection of "
"memory on\n"
"    the heap (e.g., allocated using malloc).  This is a potential security\n"
"    problem.  Applications should not be doing this. Applications are\n"
"    sometimes coded incorrectly and request this permission.  The\n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">SELinux "
"Memory Protection Tests</a>\n"
"    web page explains how to remove this requirement.  If $SOURCE does not "
"work and\n"
"    you need it to work, you can configure SELinux temporarily to allow\n"
"    this access until the application is fixed. Please file a bug\n"
"    report against this package.\n"
"    "
msgstr ""
"\n"
"    $SOURCE 应用程序试图改变堆上的内存访问保护(例如，使用 malloc 分配内存)。\n"
"    这是潜在的安全问题。应用程序不应该这样做。有时候应用程序编码不正确，会请求这样的允许。\n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">SELinux "
"内存保护测试</a>\n"
"    页面说明了怎样移除这个请求。如果 $SOURCE 不能工作而您需要它运行，\n"
"    您可以配置 SELinux 临时允许这个访问直到这个应用程序被修正。\n"
"    请发送一份关于这个软件包的 <a\n"
"    href=\"http://bugzilla.redhat.com/bugzilla/enter_bug.cgi\">错误\n"
"    报告</a> 。\n"
"    "

#: ../src/allow_execheap.py:44
msgid ""
"\n"
"    If you want $SOURCE to continue, you must turn on the\n"
"    $BOOLEAN boolean.  Note: This boolean will affect all applications\n"
"    on the system.\n"
"    "
msgstr ""
"\n"
"    如果您想让 $SOURCE 继续执行, 您必须开启\n"
"    $BOOLEAN 布尔值.  注意：这个布尔值将会影响系统中的\n"
"    所有应用程序。 \n"
" "

#: ../src/allow_execheap.py:50
msgid ""
"you do not think $SOURCE_PATH should need to map heap memory that is both "
"writable and executable."
msgstr "您不认为 $SOURCE_PATH 需要与同时可写入和执行的 heap 内存映射。"

#: ../src/allow_execheap.py:51
msgid "you need to report a bug. This is a potentially dangerous access."
msgstr "您应该报告 bug。这可能是一个有威胁的访问。"

#: ../src/allow_execheap.py:52 ../src/allow_execstack.py:84
#: ../src/kernel_modules.py:46 ../src/mmap_zero.py:48
#: ../src/selinuxpolicy.py:46 ../src/setenforce.py:29 ../src/setenforce.py:50
#: ../src/sys_module.py:30 ../src/sys_module.py:48
msgid "Contact your security administrator and report this issue."
msgstr "联络您的安全管理员并报告这个问题。"

#: ../src/allow_execmod.py:29
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from loading $TARGET_PATH which "
"requires text relocation.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE 装载需要重新定位文本的 $TARGET_PATH。\n"
"    "

#: ../src/allow_execmod.py:33
msgid ""
"\n"
"    The $SOURCE application attempted to load $TARGET_PATH which\n"
"    requires text relocation.  This is a potential security problem.\n"
"    Most libraries do not need this permission. Libraries are\n"
"    sometimes coded incorrectly and request this permission.  The\n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">SELinux "
"Memory Protection Tests</a>\n"
"    web page explains how to remove this requirement.  You can configure\n"
"    SELinux temporarily to allow $TARGET_PATH to use relocation as a\n"
"    workaround, until the library is fixed. Please file a \n"
"bug report.\n"
"    "
msgstr ""
"\n"
"    $SOURCE 应用程序试图读取需要文本重定位的 $TARGET_PATH。\n"
"    这是潜在的安全问题。\n"
"    多数程序库不需要这样做。有时候程序库编码不正确会有这样的请求。\n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">SELinux "
"内存保护测试</a>\n"
"    页面说明如何移除这个请求。您能够设置 SELinux 临时允许 $TARGET_PATH\n"
"    在工作区使用重定位直到程序库被修正。\n"
"    请生成一份关于这个程序包的    <a href=\"http://bugzilla.redhat.com/bugzilla/enter_bug."
"cgi\">错误报告</a>\n"
"    "

#: ../src/allow_execmod.py:45
msgid ""
"\n"
"    The $SOURCE application attempted to load $TARGET_PATH which\n"
"    requires text relocation.  This is a potential security problem.\n"
"    Most libraries should not need this permission.   The   \n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">\n"
"    SELinux Memory Protection Tests</a>\n"
"    web page explains this check.  This tool examined the library and it "
"looks \n"
"    like it was built correctly. So setroubleshoot can not determine if this "
"\n"
"    application is compromized or not.  This could be a serious issue. Your \n"
"    system may very well be compromised.\n"
"\n"
"    Contact your security administrator and report this issue.\n"
"\n"
"    "
msgstr ""
"\n"
"    $SOURCE 程序试图载入需要文本重新定位\n"
"    的 $TARGET_PATH。这是一个潜在的安全性问题。\n"
"    大多数程序库应该不需要这个权限。\n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">\n"
"    SELinux Memory Protection Tests</a>\n"
"    网页中解释了这个检查。这个工具检查程序库且它 \n"
"    看起来工作正常。因此 setroubleshoot "
"无法确定这个程序是否受到侵害。这可能是一个严重问题。您的系统可能受到侵害。请联络您的安全管理员并包括这个问题。\n"
"\n"
" "

#: ../src/allow_execmod.py:62
msgid ""
"\n"
"    If you trust $TARGET_PATH to run correctly, you can change the\n"
"    file context to textrel_shlib_t. \"chcon -t textrel_shlib_t\n"
"    '$TARGET_PATH'\"\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"textrel_shlib_t '$FIX_TARGET_PATH'\"\n"
"    \n"
"    "
msgstr ""
"\n"
"    如果您确信 $TARGET_PATH 正确运行，您可以将文件上下文改为\n"
" textrel_shlib_t。\"chcon -t textrel_shlib_t\n"
"    'TARGET_PATH'\"\n"
"  您还必须在系统中更改默认文件上下文文件以便在完全重新标记时可保留它们。 \"semanage fcontext -a -t "
"textrel_shlib_t '$FIX_TARGET_PATH'\"\n"
"    \n"
"    "

#: ../src/allow_execstack.py:53
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from making the program stack "
"executable.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH 使程序栈可执行。\n"
"    "

#: ../src/allow_execstack.py:57
msgid ""
"\n"
"    The $SOURCE application attempted to make its stack\n"
"    executable.  This is a potential security problem.  This should\n"
"    never ever be necessary. Stack memory is not executable on most\n"
"    OSes these days and this will not change. Executable stack memory\n"
"    is one of the biggest security problems. An execstack error might\n"
"    in fact be most likely raised by malicious code. Applications are\n"
"    sometimes coded incorrectly and request this permission.  The\n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">SELinux "
"Memory Protection Tests</a>\n"
"    web page explains how to remove this requirement.  If $SOURCE does not\n"
"    work and you need it to work, you can configure SELinux\n"
"    temporarily to allow this access until the application is fixed. Please \n"
"file a bug report.\n"
"    "
msgstr ""
"\n"
"    $SOURCE 应用程序试图使它的栈可执行。这是一个潜在的安全问题。\n"
"    这应该是完全不必要的。栈内存在多数现代操作系统中是不能够执行的，而且这是不会被改变的。\n"
"    可执行的栈内存是最大的安全问题之一。事实上，可运行栈错误很可能被恶意代码利用。\n"
"    有时候应用程序编码不正确会请求这样的允许。\n"
"    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">SELinux "
"内存保护测试</a>\n"
"    页面说明了如何移除这个请求。如果 $SOURCE 不能工作且您需要它工作，\n"
"    您可以配置 SELinux 临时允许这个访问直到应用程序被修正。\n"
"    请生成一份关于这个程序包的 <a\n"
"    href=\"http://bugzilla.redhat.com/bugzilla/enter_bug.cgi\">错误报告</a> 。\n"
"    "

#: ../src/allow_execstack.py:72
msgid ""
"\n"
"    Sometimes a library is accidentally marked with the execstack flag,\n"
"    if you find a library with this flag you can clear it with the\n"
"    execstack -c LIBRARY_PATH.  Then retry your application.  If the\n"
"    app continues to not work, you can turn the flag back on with\n"
"    execstack -s LIBRARY_PATH.  \n"
"    "
msgstr ""
"\n"
"    有些时候一个库可能被误打上 execstack 标记，\n"
"    如果您发现有库含有该标记您可以使用\n"
"    execstack -c LIBRARY_PATH 清除。 然后重新尝试程序。 如果\n"
"    程序依然不工作，您可以通过\n"
"    execstack -s LIBRARY_PATH 恢复标记。  \n"
"    "

#: ../src/allow_execstack.py:82
msgid ""
"you do not think $SOURCE_PATH should need to map stack memory that is both "
"writable and executable."
msgstr "您不认为 $SOURCE_PATH 应与同时可写入和执行的栈内存映射。"

#: ../src/allow_execstack.py:83
msgid "you need to report a bug. \n"
"This is a potentially dangerous access."
msgstr "您需要报告 bug。\n"
"这可能是一个有危险的访问。"

#: ../src/allow_execstack.py:92
#, python-format
msgid "you believe that \n"
"%s\n"
"should not require execstack"
msgstr "您确信\n"
"%s\n"
"不需要 execstack"

#: ../src/allow_execstack.py:101
#, python-format
msgid ""
"you should clear the execstack flag and see if $SOURCE_PATH works correctly.\n"
"Report this as a bug on %s.\n"
"You can clear the exestack flag by executing:"
msgstr ""
"您应该清除 execstack 标签，看看 $SOURCE_PATH 是否可以正常工作。\n"
"将其作为 bug 在 %s 中报告。\n"
"您可以执行以下命令清除 execstack 标签："

#: ../src/allow_execstack.py:111
#, python-format
msgid "execstack -c %s"
msgstr "execstack -c %s"

#: ../src/allow_ftpd_use_cifs.py:29
msgid ""
"\n"
"    SELinux prevented the ftp daemon from $ACCESS files stored on a CIFS "
"filesystem.\n"
"    "
msgstr "\n"
"    SELinux 防止 ftp 守护进程 $ACCESS 保存在 CIFS 文件系统中的文件。\n"
"    "

#: ../src/allow_ftpd_use_cifs.py:33
msgid ""
"\n"
"    SELinux prevented the ftp daemon from $ACCESS files stored on a CIFS "
"filesystem.\n"
"    CIFS (Comment Internet File System) is a network filesystem similar to\n"
"    SMB (<a href=\"http://www.microsoft.com/mind/1196/cifs.asp\">http://www."
"microsoft.com/mind/1196/cifs.asp</a>)\n"
"    The ftp daemon attempted to read one or more files or directories from\n"
"    a mounted filesystem of this type.  As CIFS filesystems do not support\n"
"    fine-grained SELinux labeling, all files and directories in the\n"
"    filesystem will have the same security context.\n"
"    \n"
"    If you have not configured the ftp daemon to read files from a CIFS "
"filesystem\n"
"    this access attempt could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止了ftp后台 $ACCESS 存储在一个CIFS文件系统中的文件。\n"
"    CIFS (通用Internet文件系统)是一个网络文件系统，它类似SMB(<a href=\"http://www.microsoft.com/"
"mind/1196/cifs.asp\">http://www.microsoft.com/mind/1196/cifs.asp</a>)\n"
"    ftp后台试图读取已经安装的这种类型的文件系统中的一个或多个文件或目录。\n"
"    由于CIFS文件系统不支持 fine-grained SELinux标志，文件系统中的所有的文件和目录将拥有一样的请安全上下文。\n"
"    \n"
"    如果您没有配置ftp后台从一个CIFS文件系统读取文件，这个访问被记为一次入侵尝试。\n"
"    "

#: ../src/allow_ftpd_use_cifs.py:46
msgid ""
"\n"
"    Changing the \"$BOOLEAN\" boolean to true will allow this access:\n"
"    \"setsebool -P $BOOLEAN=1.\"\n"
"    "
msgstr ""
"\n"
"    改变 \"$BOOLEAN\" 布尔值为 true 将允许这个访问：\n"
"    \"setsebool -P $BOOLEAN=1.\"\n"
"    "

#: ../src/allow_ftpd_use_cifs.py:53
msgid ""
" Changing the \"$BOOLEAN\" and\n"
"    \"$WRITE_BOOLEAN\" booleans to true will allow this access:\n"
"    \"setsebool -P $BOOLEAN=1 $WRITE_BOOLEAN=1\".\n"
"    warning: setting the \"$WRITE_BOOLEAN\" boolean to true will\n"
"    allow the ftp daemon to write to all public content (files and\n"
"    directories with type public_content_t) in addition to writing to\n"
"    files and directories on CIFS filesystems.  "
msgstr ""
" 修改 \"$BOOLEAN\" 和 \n"
"    \"$WRITE_BOOLEAN\" 布尔值为true将允许这个访问：\n"
"    \"setsebool -P $BOOLEAN=1 $WRITE_BOOLEAN=1\"。\n"
"    警告：设置 \"$WRITE_BOOLEAN\"布尔值为true将允许\n"
"    ftp后台向所有的公共内容(public_content_t类型的文件和目录)写入，\n"
"    也可以写入CIFS文件系统中的文件和目录。"

#: ../src/allow_ftpd_use_cifs.py:62
msgid "you want to allow ftpd to write to cifs file systems"
msgstr "您要允许 ftpd 写入 cifs 文件系统"

#: ../src/allow_ftpd_use_cifs.py:63 ../src/allow_ftpd_use_nfs.py:65
msgid "you must tell SELinux about this"
msgstr "您必须告知 SELinux 这一情况"

#: ../src/allow_ftpd_use_nfs.py:29
msgid ""
"\n"
"    SELinux prevented the ftp daemon from $ACCESS files stored on a NFS "
"filesystem.\n"
"    "
msgstr "\n"
"    SELinux 防止 ftp 守护进程 $ACCESS 保存在 NFS 文件系统中的文件。\n"
"    "

#: ../src/allow_ftpd_use_nfs.py:33
msgid ""
"\n"
"    SELinux prevented the ftp daemon from $ACCESS files stored on a NFS "
"filesystem.\n"
"    NFS (Network Filesystem) is a network filesystem commonly used on Unix / "
"Linux\n"
"    systems.\n"
"    \n"
"    The ftp daemon attempted to read one or more files or directories from\n"
"    a mounted filesystem of this type.  As NFS filesystems do not support\n"
"    fine-grained SELinux labeling, all files and directories in the\n"
"    filesystem will have the same security context.\n"
"    \n"
"    If you have not configured the ftp daemon to read files from a NFS "
"filesystem\n"
"    this access attempt could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止了ftp后台 $ACCESS 存储在NFS文件系统中的文件。\n"
"    NFS(网络文件系统)是一个通常在Unix和Linux下被使用的网络文件系统。\n"
"    \n"
"    ftp后台试图从已经挂接的这种类型的文件操作系统中读取一个或多个文件或目录。\n"
"    由于NFS文件系统不支持fine-grained的SELinux标志。在此文件系统下所有的文件和目录将拥有相同的安全上下文。\n"
"    \n"
"    如果您没有配置ftp后台从NFS文件系统中读取文件，这个访问被记为一次入侵尝试。\n"
"    "

#: ../src/allow_ftpd_use_nfs.py:47
msgid ""
"\n"
"    Changing the \"allow_ftpd_use_nfs\" boolean to true will allow this "
"access:\n"
"    \"setsebool -P allow_ftpd_use_nfs=1.\"\n"
"    "
msgstr ""
"\n"
"    改变 \"allow_ftpd_use_nfs\" 的布尔值为 true 将允许这个访问：\n"
"    \"setsebool -P allow_ftpd_use_nfs=1.\"\n"
"    "

#: ../src/allow_ftpd_use_nfs.py:54
msgid ""
" Changing the \"allow_ftpd_use_nfs\" and\n"
"    \"$WRITE_BOOLEAN\" booleans to true will allow this access:\n"
"    \"setsebool -P allow_ftpd_use_nfs=1 $WRITE_BOOLEAN=1\".\n"
"    warning: setting the \"$WRITE_BOOLEAN\" boolean to true will\n"
"    allow the ftp daemon to write to all public content (files and\n"
"    directories with type public_content_t) in addition to writing to\n"
"    files and directories on NFS filesystems.  "
msgstr ""
" 修改 \"allow_ftpd_use_nfs\" 和\n"
"    \"$WRITE_BOOLEAN\"布尔值为true将允许这个访问：\n"
"    \"setsebool -P allow_ftpd_use_nfs=1$WRITE_BOOLEAN=1\"。\n"
"    "
"警告：设置\"$WRITE_BOOLEAN\"布尔值为true将允许ftp后台写入所有公共内容(public_content_t类型的文件和目录)，\n"
"    另外，也允许写入NFS文件系统中的文件和目录。"

#: ../src/allow_ftpd_use_nfs.py:64
msgid "you want to allow ftpd to write to nfs file systems"
msgstr "您要允许 ftpd 写入 nfs 文件系统"

#: ../src/associate.py:32 ../src/openvpn.py:31 ../src/public_content.py:27
#: ../src/qemu_blk_image.py:27 ../src/qemu_file_image.py:27
#: ../src/restorecon.py:42 ../src/restorecon_source.py:33
#: ../src/rsync_data.py:27 ../src/sshd_root.py:32
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH \"$ACCESS\" access to $TARGET_PATH.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH \"$ACCESS\" 访问设备 $TARGET_PATH。\n"
"    "

#: ../src/associate.py:37
#, python-format
msgid ""
"\n"
"You tried to place a type on a %s that is not a file type.  This is not "
"allowed, you must assigne a file type.  You can list all file types using "
"the seinfo command.\n"
"\n"
"seinfo -afile_type -x\n"
"\n"
"    "
msgstr ""
"\n"
"您尝试在 %s 设定的类型并非一个文件类型。  这是不允许的，您必须指定一个文件类型。  您可以使用 seinfo 命令列出所有文件类型。\n"
"\n"
"seinfo -afile_type -x\n"
"\n"
"    "

#: ../src/associate.py:44
#, python-format
msgid ""
"you want to change the label of $TARGET_PATH to %s, you are not allowed to "
"since it is not a valid file type."
msgstr "您想要改变 $TARGET_PATH 的标签为 %s ，该操作不被允许因为那不是个合法的文件类型。"

#: ../src/associate.py:49
msgid "you must pick a valid file label."
msgstr "您必须挑选一个合法的文件标签。"

#: ../src/automount_exec_config.py:27
msgid ""
"\n"
"    SELinux is preventing the $SOURCE_PATH from executing potentially "
"mislabeled files $TARGET_PATH.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH 执行可能错误标记的文件 $TARGET_PATH 。\n"
"    "

#: ../src/automount_exec_config.py:31
msgid ""
"\n"
"    SELinux has denied the $SOURCE_PATH from executing potentially\n"
"    mislabeled files $TARGET_PATH.  Automounter can be setup to execute\n"
"    configuration files. If $TARGET_PATH is an automount executable\n"
"    configuration file it needs to have a file label of bin_t.\n"
"    If automounter is trying to execute something that it is not supposed "
"to, this could indicate an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"  SELinux 已经拒绝 $SOURCE_PATH 执行可能错\n"
"  误标记的文件 $TARGET_PATH。可将 automounter 设置为\n"
"  执行配置文件，如果 $TARGET_PATH 是一个自动挂载可执行\n"
"  配置文件，则需要有一个 bin_t 文件标记。\n"
"  如果 automounter 正在试图执行它不应该执行的动作， 则可能是一个入侵攻击提示。\n"
" "

#: ../src/automount_exec_config.py:39
msgid ""
"\n"
"    If you want to change the file context of $TARGET_PATH so that the "
"automounter can execute it you can execute \"chcon -t bin_t $TARGET_PATH\".  "
"If you want this to survive a relabel, you need to permanently change the "
"file context: execute  \"semanage fcontext -a -t bin_t '$FIX_TARGET_PATH'\".\n"
"    "
msgstr ""
"\n"
"    如果您要更改 $TARGET_PATH 的文件上下文以便自动挂载程序可执行它，您可以执行 \"chcon -t bin_t "
"$TARGET_PATH\"。如果您要在重新标记后仍保留它，您需要永久更改文件上下文： 请执行  \"semanage fcontext -a -t "
"bin_t '$FIX_TARGET_PATH'\"。\n"
"    "

#: ../src/bind_ports.py:27
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from binding to port $PORT_NUMBER.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE 绑定到端口 $PORT_NUMBER。\n"
"    "

#: ../src/bind_ports.py:31
#, python-format
msgid ""
"\n"
"    SELinux has denied the $SOURCE from binding to a network port "
"$PORT_NUMBER which does not have an SELinux type associated with it.\n"
"    If $SOURCE should be allowed to listen on $PORT_NUMBER, use the "
"<i>semanage</i> command to assign $PORT_NUMBER to a port type that "
"$SOURCE_TYPE can bind to (%s). \n"
"    \n"
"\n"
"If $SOURCE is not supposed\n"
"    to bind to $PORT_NUMBER, this could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 已拒绝 $SOURCE 捆绑到网络端口 $PORT_NUMBER，已经有与之关联的 SELinux 类型。\n"
"    如果应允许 $SOURCE 侦听 $PORT_NUMBER，请使用 <i>semanage</i> 命令为可捆绑 "
"$SOURCE_TYPE的端口类型指定 $PORT_NUMBER (%s). \n"
"    \n"
"\n"
"如果 $SOURCE 不应\n"
"    捆绑到 $PORT_NUMBER，则这可能是入侵尝试信号。\n"
"    "

#: ../src/bind_ports.py:38
#, python-format
msgid ""
"\n"
"    If you want to allow $SOURCE to bind to port $PORT_NUMBER, you can "
"execute \n"
"\n"
"    # semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"    \n"
"where PORT_TYPE is one of the following: %s.\n"
"\n"
"    \n"
"\n"
"If this system is running as an NIS Client, turning on the allow_ypbind "
"boolean may fix the problem.  setsebool -P allow_ypbind=1.\n"
"    "
msgstr ""
"\n"
"    如果您要允许 $SOURCE 捆绑到端口 $PORT_NUMBER，可以执行\n"
"\n"
"    # semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"    \n"
"其中 PORT_TYPE 是以下之一：%s。\n"
"\n"
"    \n"
"\n"
"如果这个系统是作为 NIS 客户端运行，打开 allow_ypbind 布尔可纠正这个问题。setsebool -P allow_ypbind=1。\n"
"    "

#: ../src/bind_ports.py:53 ../src/connect_ports.py:52
#, python-format
msgid ""
"# semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"    where PORT_TYPE is one of the following: %s."
msgstr ""
"# semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"    其中 PORT_TYPE 是以下之一：%s。"

#: ../src/bind_ports.py:56 ../src/connect_ports.py:55
#, python-format
msgid "# semanage port -a -t %s -p %s $PORT_NUMBER"
msgstr "# semanage port -a -t %s -p %s $PORT_NUMBER"

#: ../src/catchall_boolean.py:32
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH \"$ACCESS\" access on $TARGET_PATH.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE \"$ACCESS\" 访问设备 $TARGET_PATH。\n"
"    "

#: ../src/catchall_boolean.py:36
msgid ""
"\n"
"\n"
"    SELinux denied access requested by $SOURCE. The current boolean \n"
"    settings do not allow this access.  If you have not setup $SOURCE to\n"
"    require this access this may signal an intrusion attempt. If you do "
"intend \n"
"    this access you need to change the booleans on this system to allow \n"
"    the access.\n"
"    "
msgstr ""
"\n"
"\n"
"    SELinux 拒绝了 $SOURCE 请求的访问。当前的布尔值\n"
"    设置并不允许这个访问。如果您没有将 $SOURCE 设置为请求这种访问，它可能是尝试入侵的一\n"
"    个信号。如果您确实需要这个访问，您需要修改这个系统的布尔值以便允许这个访问。\n"
"    "

#: ../src/catchall_boolean.py:45
msgid ""
"\n"
"    Confined processes can be configured to run requiring different access, "
"SELinux provides booleans to allow you to turn on/off \n"
"    access as needed.\n"
"\n"
"    "
msgstr ""
"\n"
"    受限制的进程可以配置为需要在不同访问权限下运行， SELinux 提供布尔值以便允许您根据需要打开/关闭 \n"
"    访问权限。\n"
"\n"
"    "

#: ../src/catchall_boolean.py:62
#, python-format
msgid "you want to %s"
msgstr "您要 %s"

#: ../src/catchall_boolean.py:65
#, python-format
msgid "setsebool -P %s %s"
msgstr "setsebool -P %s %s"

#: ../src/catchall_boolean.py:68
#, python-format
msgid "You must tell SELinux about this by enabling the '%s' boolean.\n"
msgstr "您必须启用 '%s' 布尔值告知 SELinux 此情况。\n"

#: ../src/catchall_boolean.py:71
#, python-format
msgid "You can read '%s' man page for more details."
msgstr "您可以阅读 '%s' 手册页面来了解详情。"

#: ../src/catchall_labels.py:28
#, python-format
msgid ""
"\n"
"    SELinux has denied the $SOURCE access to potentially\n"
"    mislabeled files $TARGET_PATH.  This means that SELinux will not\n"
"    allow httpd to use these files. If httpd should be allowed this access "
"to these files you should change the file context to one of the following "
"types, %s.\n"
"    Many third party apps install html files\n"
"    in directories that SELinux policy cannot predict.  These directories\n"
"    have to be labeled with a file context which httpd can access.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 $SOURCE 对可能错误标记文件 $TARGET_PATH  \n"
"    的访问。这意味着 SELinux 将不允许 httpd 使用这些文件。如果应该允许 httpd \n"
"    访问这些文件，那么您应该将该文件的上下文更改为以下类型 %s。\n"
"    许多第三方应用程\n"
"    序将 html 文件安装在 SELinux 策略无法预知的目录。这些目录必须以一个 \n"
"    httpd 能访问的文件上下文被标记。\n"
"    "

#: ../src/catchall_labels.py:37
msgid "You need to change the label on $FIX_TARGET_PATH"
msgstr "您必须更改 $FIX_TARGET_PATH 中的标签"

#: ../src/catchall_labels.py:40
#, python-format
msgid ""
"# semanage fcontext -a -t FILE_TYPE '$FIX_TARGET_PATH'\n"
"where FILE_TYPE is one of the following: %s. \n"
"Then execute: \n"
"restorecon -v '$FIX_TARGET_PATH'\n"
msgstr ""
"# semanage fcontext -a -t FILE_TYPE '$FIX_TARGET_PATH'\n"
"其中 FILE_TYPE 是以下情况之一：%s。\n"
"然后执行：\n"
"restorecon -v '$FIX_TARGET_PATH'\n"

#: ../src/catchall.py:29 ../src/chrome.py:29 ../src/mozplugger.py:29
#: ../src/mozplugger_remove.py:29
msgid "SELinux is preventing $SOURCE_PATH \"$ACCESS\" access."
msgstr "SELinux 防止 $SOURCE_PATH \"$ACCESS\" 访问。"

#: ../src/catchall.py:31
msgid ""
"\n"
"\n"
"    SELinux denied access requested by $SOURCE. It is not\n"
"    expected that this access is required by $SOURCE and this access\n"
"    may signal an intrusion attempt. It is also possible that the specific\n"
"    version or configuration of the application is causing it to require\n"
"    additional access.\n"
"\n"
"    "
msgstr ""
"\n"
"\n"
"    SELinux 拒绝了 $SOURCE 的访问请求。\n"
"    $SOURCE 并不应请求这种访问，它可能是尝试入侵的一\n"
"    个信号。也可能是应用程序的特别版本或配置导致它请求额外的访问。\n"
"\n"
"    "

#: ../src/catchall.py:41
msgid ""
"\n"
"    You can generate a local policy module to allow this\n"
"    access - see <a href=\"http://docs.fedoraproject.org/selinux-faq-fc5/"
"#id2961385\">FAQ</a>\n"
"\n"
"    Please file a bug report.\n"
"    "
msgstr ""
"\n"
"    您可以创建一个本地策略模块来允许这个\n"
"    访问 - 请查看 <a href=\"http://fedora.redhat.com/docs/selinux-faq-fc5/"
"#id2961385\">常见问题</a>\n"
"    请发送一个 bug 报告。\n"
"    "

#: ../src/catchall.py:50
msgid ""
"you believe that $SOURCE_BASE_PATH should be allowed $ACCESS access on "
"processes labeled $TARGET_TYPE by default."
msgstr "您确定应默认允许 $SOURCE_BASE_PATH $ACCESS 标记为 $TARGET_TYPE 的进程。"

#: ../src/catchall.py:52
msgid ""
"you believe that $SOURCE_BASE_PATH should have the $ACCESS capability by "
"default."
msgstr "您确定 $SOURCE_BASE_PATH 应默认有 $ACCESS 功能。"

#: ../src/catchall.py:53
msgid ""
"you believe that $SOURCE_BASE_PATH should be allowed $ACCESS access on the "
"$TARGET_BASE_PATH $TARGET_CLASS by default."
msgstr ""
"您确定应默认允许 $SOURCE_BASE_PATH $ACCESS 访问 $TARGET_BASE_PATH $TARGET_CLASS。"

#: ../src/catchall.py:55
msgid ""
"You should report this as a bug.\n"
"You can generate a local policy module to allow this access."
msgstr "您应该将这个情况作为 bug 报告。\n"
"您可以生成本地策略模块允许这个访问。"

#: ../src/catchall.py:56
msgid ""
"Allow this access for now by executing:\n"
"# grep $SOURCE /var/log/audit/audit.log | audit2allow -M mypol\n"
"# semodule -i mypol.pp"
msgstr ""
"请执行以下命令此时允许这个访问：\n"
"# grep $SOURCE /var/log/audit/audit.log | audit2allow -M mypol\n"
"# semodule -i mypol.pp"

#: ../src/connect_ports.py:27 ../src/sandbox_connect.py:29
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from connecting to port $PORT_NUMBER.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH 连接到端口 $PORT_NUMBER。\n"
"    "

#: ../src/connect_ports.py:31
#, python-format
msgid ""
"\n"
"    SELinux has denied $SOURCE from connecting to a network port "
"$PORT_NUMBER which does not have an SELinux type associated with it.\n"
"    If $SOURCE should be allowed to connect on $PORT_NUMBER, use the "
"<i>semanage</i> command to assign $PORT_NUMBER to a port type that "
"$SOURCE_TYPE can connect to (%s). \n"
"    \n"
"\n"
"If $SOURCE is not supposed\n"
"    to connect to $PORT_NUMBER, this could signal a intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 已拒绝 $SOURCE 连接到网络端口 $PORT_NUMBER，该端口没有与之关联的 SELinux 类型。\n"
"    如果应允许 $SOURCE 与 $PORT_NUMBER 连接，请使用 <i>semanage</i> 命令为 $SOURCE_TYPE "
"可连接的端口类型分配 $PORT_NUMBER (%s)。 \n"
"    \n"
"\n"
"如果 $SOURCE 不应\n"
"    连接到 $PORT_NUMBER，这就是入侵尝试信号。\n"
"    "

#: ../src/connect_ports.py:39
#, python-format
msgid ""
"\n"
"    If you want to allow $SOURCE to connect to $PORT_NUMBER, you can execute "
"\n"
"\n"
"    # semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"\n"
"    where PORT_TYPE is one of the following: %s.\n"
"    "
msgstr ""
"\n"
"    如果您要允许 $SOURCE 连接到 $PORT_NUMBER，您可以执行 \n"
"\n"
"    # semanage port -a -t PORT_TYPE -p %s $PORT_NUMBER\n"
"\n"
"    其中 PORT_TYPE 是以下之一：%s。\n"
"    "

#: ../src/chrome.py:31
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. It is not expected that this "
"access is required by $SOURCE and this access may signal an intrusion "
"attempt. It is also possible that the specific version or configuration of "
"the application is causing it to require additional access.  spice-xpi run "
"applications within mozilla-plugins that require access to the desktop, that "
"the mozilla_plugin lockdown will not allow, so either you need to turn off "
"the mozilla_plugin lockdown or not use these packages.\n"
"    "
msgstr ""

#: ../src/chrome.py:35
msgid ""
"\n"
"Either remove the mozplugger or spice-xpi package by executing 'yum remove "
"mozplugger spice-xpi', or turn off enforcement of SELinux over the Chrome "
"plugins. setsebool -P unconfined_chrome_sandbox_transition 0\n"
"    "
msgstr ""

#: ../src/chrome.py:38 ../src/mozplugger.py:38
#, python-format
msgid "you want to use the %s package"
msgstr "您要使用 %s 软件包"

#: ../src/chrome.py:43
msgid "you must turn off SELinux controls on the Chrome plugins."
msgstr "您必须关闭 SELinux 对于 Chrome 插件的控制。"

#: ../src/cvs_data.py:27
msgid ""
"\n"
"    SELinux is preventing cvs ($SOURCE_PATH) \"$ACCESS\" access to "
"$TARGET_PATH\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 cvs ($SOURCE_PATH) \"$ACCESS\" 访问设备 $TARGET_PATH\n"
"    "

#: ../src/cvs_data.py:31
msgid ""
"\n"
"    SELinux denied cvs access to $TARGET_PATH.\n"
"    If this is a CVS repository it needs to have a file context label of\n"
"    cvs_data_t. If you did not intend to use $TARGET_PATH as a CVS "
"repository\n"
"    it could indicate either a bug or it could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了cvs 访问 $TARGET_PATH。\n"
"    如果这是一个 CVS 程序库，它应当有一个文件上下文标记 cvs_data_t。\n"
"    如果您并没有打算将 $TARGET_PATH 作为 CVS 程序库使用，这可能是\n"
"    一个 Bug 或是入侵尝试的信号。   \n"
" "

#: ../src/cvs_data.py:38
msgid ""
"\n"
"    You can alter the file context by executing chcon -R -t cvs_data_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"cvs_data_t '$FIX_TARGET_PATH'\"\n"
"    \n"
"    "
msgstr ""
"\n"
"    您可以通过执行 chcon -R -t cvs_data_t '$TARGET_PATH' 修改文件上下文。\n"
"    您还必须修改系统中的默认文件上下文文件以便在完全重新标记后还可以保留它们。\"semanage fcontext -a -t "
"vcs_data_t '$FIX_TARGET_PATH'\"\n"
"    \n"
" "

#: ../src/cvs_data.py:44
msgid "$TARGET_BASE_PATH should be shared via the cvs daemon"
msgstr "应通过 cvs 守护进程共享 $TARGET_BASE_PATH "

#: ../src/cvs_data.py:45 ../src/qemu_file_image.py:49
msgid "You need to change the label on $TARGET_BASE_PATH'"
msgstr "您需要更改 $TARGET_BASE_PATH' 中的标签"

#: ../src/dac_override.py:28
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH the \"$ACCESS\" capability. \n"
"    "
msgstr "\n"
"    SELinux 阻止 $SOURCE_PATH 的 \"$ACCESS\" 功能。 \n"
"    "

#: ../src/dac_override.py:32
msgid ""
"\n"
"\tdac_override and dac_read_search capabilities usually indicates that the "
"root process does not have access to a file based on the permission flags.  "
"This usually mean you have some file with the wrong ownership/permissions on "
"it.\n"
"    "
msgstr ""
"\n"
"\tdac_override 和 dac_read_search 功能通常说明 root 进程根据权限标签不能访问某个文件。这通常意味着有些文件的拥有者/"
"权限是错误的。\n"
"    "

#: ../src/dac_override.py:38
msgid ""
"you want to help identify if domain needs this access or you have a file "
"with the wrong permissions on your system"
msgstr "您想要帮助识别域是否需要这个访问或您的系统中有拥有错误权限的文件"

#: ../src/dac_override.py:39
msgid ""
"turn on full auditing to get path information about the offending file and "
"generate the error again."
msgstr "打开全面审核以获得有关违规文件路径信息并再次生成该错误。"

#: ../src/dac_override.py:40
msgid ""
"\n"
"Turn on full auditing\n"
"# auditctl -w /etc/shadow -p w\n"
"Try to recreate AVC. Then execute\n"
"# ausearch -m avc -ts recent\n"
"If you see PATH record check ownership/permissions on file, and fix it, \n"
"otherwise report as a bugzilla."
msgstr ""
"\n"
"打开全面审核\n"
"# auditctl -w /etc/shadow -p w\n"
"尝试重新生成 AVC。然后执行\n"
"# ausearch -m avc -ts recent\n"
"如果您看到 PATH 记录检查文件的拥有者/权限，请改正， \n"
"否则请向 bugzilla 报告。"

#: ../src/device.py:29
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH \"$ACCESS\" access to device "
"$TARGET_PATH. \n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH \"$ACCESS\" 访问设备 $TARGET_PATH。\n"
"    "

#: ../src/device.py:33
msgid ""
"\n"
"\n"
"    SELinux has denied $SOURCE \"$ACCESS\" access to device $TARGET_PATH.\n"
"    $TARGET_PATH is mislabeled, this device has the default label of the /"
"dev directory, which should not\n"
"    happen.  All Character and/or Block Devices should have a label.\n"
"\n"
"    You can attempt to change the label of the file using\n"
"\n"
"    restorecon -v '$TARGET_PATH'.\n"
"\n"
"    If this device remains labeled device_t, then this is a bug in SELinux "
"policy.\n"
"\n"
"    Please file a bg report.\n"
"\n"
"    If you look at the other similar devices labels, ls -lZ /dev/SIMILAR, "
"and find a type that would work for $TARGET_PATH,\n"
"    you can use chcon -t SIMILAR_TYPE '$TARGET_PATH', If this fixes the "
"problem, you can make this permanent by executing\n"
"    semanage fcontext -a -t SIMILAR_TYPE '$FIX_TARGET_PATH'\n"
"\n"
"    If the restorecon changes the context, this indicates that the "
"application that created the device, created it without\n"
"    using SELinux APIs.  If you can figure out which application created the "
"device, please file a bug report against this application.\n"
"    \n"
"    "
msgstr ""
"\n"
"\n"
"    SELinux 已经拒绝了 $SOURCE \"$ACCESS\" 访问设备 $TARGET_PATH。\n"
"    $TARGET_PATH错误标记了，这个设备的默认标签是 /dev 目录的，这本不应该发生。\n"
"    所有的字符设备和/或者块设备都应该有一个标签。\n"
"\n"
"    您可以使用以下命令来更改文件的标签：\n"
"\n"
"    restorecon -v '$TARGET_PATH'。\n"
"\n"
"    如果这个设备的标签仍被标记为 device_t，这可能是 SELinux 策略中的一个 bug。\n"
"\n"
"    请填写一个 bug 报告\n"
"    来反映与 selinux-policy 软件包相关的问题。\n"
"\n"
"    您可以查看其它相似设备的标签，ls -lZ /dev/SIMILAR，并找到一个对 $TARGET_PATH 有效的类型，\n"
"    您可以使用 chcon -t SIMILAR_TYPE "
"'$TARGET_PATH'。如果这个方法解决了这个问题，您可以执行以下命令来永久改变它：\n"
"    semanage fcontext -a -t SIMILAR_TYPE '$FIX_TARGET_PATH'\n"
"\n"
"    如果 restorecon 改变了上下文，这意味着创建这个设备的应用程序在创建该设备时没有使用 SELinux API。\n"
"    如果您可以找出哪个应用程序创建了这个设备，请填写一个 bug 报告\n"
"    来反映这个应用程序的问题。\n"
"    \n"
"    "

#: ../src/device.py:56
msgid ""
"\n"
"    Attempt restorecon -v '$TARGET_PATH' or chcon -t SIMILAR_TYPE "
"'$TARGET_PATH'\n"
"    "
msgstr ""
"\n"
"    尝试 restorecon -v '$TARGET_PATH' 或 chcon -t SIMILAR_TYPE '$TARGET_PATH'\n"
"    "

#: ../src/device.py:60
msgid ""
"You need to change the label on $TARGET_PATH to a type of a similar device."
msgstr "您需要将 $TARGET_PATH 的标签改为类似设备类型。"

#: ../src/device.py:61
msgid ""
"# semanage fcontext -a -t SIMILAR_TYPE '$FIX_TARGET_PATH'\n"
"# restorecon -v '$FIX_TARGET_PATH'"
msgstr ""
"# semanage fcontext -a -t SIMILAR_TYPE '$FIX_TARGET_PATH'\n"
"# restorecon -v '$FIX_TARGET_PATH'"

#: ../src/disable_ipv6.py:30
msgid "\n"
"Disable IPV6 properly.\n"
"    "
msgstr "\n"
"正确禁用 IPV6。\n"
"    "

#: ../src/disable_ipv6.py:40
msgid "you want to disable IPV6 on this machine"
msgstr "您要在这台机器中禁用 IPV6"

#: ../src/disable_ipv6.py:41
msgid ""
"you need to set /proc/sys/net/ipv6/conf/all/disable_ipv6 to 1 and do not "
"blacklist the module'"
msgstr "您需要将 /proc/sys/net/ipv6/conf/all/disable_ipv6 设定为 1，且不要将该模块放入黑名单"

#: ../src/disable_ipv6.py:42
msgid "Add \n"
"net.ipv6.conf.all.disable_ipv6 = 1\n"
"to /etc/sysctl.conf\n"
msgstr "在 \n"
"/etc/sysctl.conf 中\n"
"添加 net.ipv6.conf.all.disable_ipv6 = 1\n"

#: ../src/file.py:27
msgid ""
"\n"
"    SELinux is preventing access to files with the label, file_t.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止访问使用file_t标签的文件。\n"
"    "

#: ../src/file.py:31
msgid ""
"\n"
"    SELinux permission checks on files labeled file_t are being\n"
"    denied.  file_t is the context the SELinux kernel gives to files\n"
"    that do not have a label. This indicates a serious labeling\n"
"    problem. No files on an SELinux box should ever be labeled file_t.\n"
"    If you have just added a disk drive to the system you can\n"
"    relabel it using the restorecon command.  For example if you saved the\n"
"home directory from a previous installation that did not use SELinux, "
"'restorecon -R -v /home' will fix the labels.  Otherwise you should\n"
"    relabel the entire file system.\n"
"    "
msgstr ""
"\n"
"    SELinux 在标示为 file_t 的文件许可检查被\n"
"    拒绝。  file_t 是 SELinux 内核赋予无标签\n"
"    文件的上下文。 这意味着一个严重的标注\n"
"    问题。 在 SELinux 机器上不该有任何文件标注为 file_t。\n"
"    如果您刚刚为系统添加了一个驱动器您可以\n"
"    使用 restorecon 命令重新标注它。  举例来说您保留\n"
"先前安装中未使用 SELinux 的 home 目录，'restorecon -R -v /home' 将修复标签。否则您应该\n"
"    重新标注整个文件系统。\n"
"    "

#: ../src/file.py:42
msgid ""
"\n"
"    You can execute the following command as root to relabel your\n"
"    computer system: \"touch /.autorelabel; reboot\"\n"
"    "
msgstr ""
"\n"
"    您可以以 root 身份执行以下命令来重新设置您计算机系统的标签：\n"
"    \"touch /.autorelabel; reboot\"\n"
"    "

#: ../src/file.py:49
msgid "this is caused by a newly created file system."
msgstr "这是由新生成的文件系统造成的。"

#: ../src/file.py:51
msgid "you think this is caused by a badly mislabeled machine."
msgstr "您认为这是由严重错误标记的机器造成的。"

#: ../src/file.py:55
msgid "you need to add labels to it."
msgstr "您需要在其中添加标签。"

#: ../src/file.py:57
msgid "you need to fully relabel."
msgstr "您需要全部重新标记。"

#: ../src/filesystem_associate.py:27
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH from creating a file with a context "
"of $SOURCE_TYPE on a filesystem.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH 在文件系统中生成一个上下文为 $SOURCE_TYPE 的文件。\n"
"    "

#: ../src/filesystem_associate.py:31
msgid ""
"\n"
"    SELinux is preventing $SOURCE from creating a file with a context of "
"$SOURCE_TYPE on a filesystem.\n"
"    Usually this happens when you ask the cp command to maintain the context "
"of a file when\n"
"    copying between file systems, \"cp -a\" for example.  Not all file "
"contexts should be maintained\n"
"    between the file systems.  For example, a read-only file type like "
"iso9660_t should not be placed\n"
"    on a r/w system.  \"cp -p\" might be a better solution, as this will "
"adopt the default file context\n"
"    for the destination.  \n"
"    "
msgstr ""
"\n"
"    SELinux 阻止 $SOURCE 在文件系统中生成上下文为 $SOURCE_TYPE 的文件。\n"
"    通常会在您在文件系统间复制时使用 cp 命令 维护文件的上下文\n"
"    时发生，比如 \"cp -a\"。不是所有文件在不同  Not all file 文件系统间进行复制时\n"
"    都需要维护其上下文。例如：只读文件 iso9660_t 就不应放在\n"
"    r/w 系统中。\"cp -p\" 应该是较好的解决方案，因为这样可 在目的文件中采用默认的\n"
"    文件上下文。  \n"
"    "

#: ../src/filesystem_associate.py:40
msgid ""
"\n"
"    Use a command like \"cp -p\" to preserve all permissions except SELinux "
"context.\n"
"    "
msgstr "\n"
"    使用命令 \"cp -p\" 保留 SELinux 外的所有 权限。\n"
"    "

#: ../src/filesystem_associate.py:43
msgid ""
"you believe $SOURCE_BASE_PATH should be allowed to create $TARGET_BASE_PATH "
"files"
msgstr "您确定应允许 $SOURCE_BASE_PATH 生成 $TARGET_BASE_PATH 文件"

#: ../src/filesystem_associate.py:44
msgid ""
"you need to use a different command. You are not allowed to preserve the "
"SELinux context on the target file system."
msgstr "您需要使用不同命令。不允许您在目标文件系统中保留 SELinux 上下文。"

#: ../src/filesystem_associate.py:46
msgid ""
"use a command like \"cp -p\" to preserve all permissions except SELinux "
"context."
msgstr "使用类似 \"cp -p\" 的命令保留 SELinux 上下文之外的所有权限。"

#: ../src/httpd_can_sendmail.py:28
msgid "\n"
"    SELinux is preventing the http daemon from sending mail.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 http 守护进程发送电子邮件。\n"
"    "

#: ../src/httpd_can_sendmail.py:32
msgid ""
"\n"
"    SELinux has denied the http daemon from sending mail. An\n"
"    httpd script is trying to connect to a mail port or execute the \n"
"    sendmail command. If you did not setup httpd to sendmail, this could \n"
"    signal a intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 http 守护进程发送电子邮件。一个 httpd 脚本正试图连接到\n"
"    一个电子邮件端口或者执行 sendmail 命令。如果您没有将 httpd 设置发送的足可，这可能是入侵\n"
"    尝试的信号。\n"
"    "

#: ../src/httpd_can_sendmail.py:39
msgid ""
"\n"
"    If you want httpd to send mail you need to turn on the\n"
"    $BOOLEAN boolean: \"setsebool -P\n"
"    $BOOLEAN=1\"\n"
"    "
msgstr ""
"\n"
"    如果您想允许 httpd 发送电子邮件，您需要开启 $BOOLEAN 布尔值：\n"
"    \"setsebool -P $BOOLEAN=1\"\n"
"    "

#: ../src/httpd_can_sendmail.py:47
msgid "you want to allow httpd to send mail"
msgstr "您要允许 httpd 发送邮件"

#: ../src/httpd_can_sendmail.py:48
msgid "you must setup SELinux to allow this"
msgstr "您不许将 SELinux 设定为允许这个动作"

#: ../src/httpd_unified.py:29
msgid "\n"
"    SELinux prevented httpd $ACCESS access to http files.\n"
"    "
msgstr "\n"
"    SELinux 阻止 httpd $ACCESS 访问 http 文件。\n"
"    "

#: ../src/httpd_unified.py:33
msgid ""
"\n"
"    SELinux prevented httpd $ACCESS access to http files.\n"
"\n"
"    Ordinarily httpd is allowed full access to all files labeled with http "
"file\n"
"    context.  This machine has a tightened security policy with the $BOOLEAN\n"
"    turned off,  This requires explicit labeling of all files.  If a file is\n"
"    a cgi script it needs to be labeled with httpd_TYPE_script_exec_t in "
"order\n"
"    to be executed.  If it is read only content, it needs to be labeled\n"
"    httpd_TYPE_content_t, it is writable content. it needs to be labeled\n"
"    httpd_TYPE_script_rw_t or httpd_TYPE_script_ra_t. You can use the\n"
"    chcon command to change these context.  Please refer to the man page\n"
"    \"man httpd_selinux\" or \n"
"    <a href=\"http://fedora.redhat.com/docs/selinux-apache-fc3\">FAQ</a>\n"
"    \"TYPE\" refers to one of \"sys\", \"user\" or \"staff\" or potentially "
"other\n"
"    script types.\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止 httpd $ACCESS 访问 http 文件。\n"
"\n"
"    通常允许 httpd 全面访问所有使用 http 文件上下文标记的文件\n"
"    这台机器由于关闭 $BOOLEAN 而限制了安全策略。\n"
"    这就要求明确标记所有文件。如果某个文件\n"
"    是 cgi 脚本，则需要使用 httpd_TYPE_script_exec_t 标记方可\n"
"    执行。如果是只读内容，则需将其标记为\n"
"    httpd_TYPE_content_t，如果是可写入内容，则需将其\n"
"    标记为 httpd_TYPE_script_rw_t 或 httpd_TYPE_script_ra_t。您可以使用\n"
"    chcon 命令更改这些上下文。详情请参考\n"
"    \"man httpd_selinux\" man page 或 \n"
"    <a href=\"http://fedora.redhat.com/docs/selinux-apache-fc3\">FAQ</a>\n"
"    \"TYPE\" 指的是 \"sys\", \"user\" 或 \"staff\" 之一，也可能是其他\n"
"    脚本类型。\n"
"    "

#: ../src/httpd_unified.py:50
msgid ""
"\n"
"    Changing the \"$BOOLEAN\" boolean to true will allow this access:\n"
"    \"setsebool -P $BOOLEAN=1\"\n"
"    "
msgstr ""
"\n"
"    改变 \"$BOOLEAN\" 布尔值为 true 将允许这个访问：\n"
"    \"setsebool -P $BOOLEAN=1\"\n"
"    "

#: ../src/httpd_unified.py:57
msgid ""
"you want to allow httpd to execute cgi scripts and to unify HTTPD handling "
"of all content files."
msgstr "您要允许 httpd 执行 cgi 脚本，并统一所有内容文件的 HTTPD 句柄。"

#: ../src/httpd_unified.py:58
msgid ""
"you must tell SELinux about this by enabling the 'httpd_unified' and "
"'http_enable_cgi' booleans"
msgstr "您必须通过启用 'httpd_unified' 和 'http_enable_cgi' 布尔告知 SELinux 这个情况"

#: ../src/httpd_write_content.py:30
msgid ""
"\n"
"    SELinux prevented httpd $ACCESS access to $TARGET_PATH.\n"
"\n"
"    httpd scripts are not allowed to write to content without explicit \n"
"    labeling of all files.  If $TARGET_PATH is writable content. it needs \n"
"    to be labeled httpd_sys_rw_content_t or if all you need is append you "
"can label it httpd_sys_ra_content_t.   Please refer to 'man httpd_selinux' "
"for more information on setting up httpd and selinux.\n"
"    "
msgstr ""
"\n"
"    SELinux阻止了 httpd $ACCESS 访问 $TARGET_PATH。\n"
"\n"
"   httpd 脚本不允许对没有被显式标记的所有文件的内容作写操作。如果 $TARGET_PATH 是可改写内容，它必须被标记为 "
"httpd_sys_rw_content_t，或者如果您要的只是添加内容，可以把它标记为 httpd_sys_ra_content_t。请参考“man "
"httpd_selinux” 来了解更多搭建 httpd 和 selinux 的信息。"

#: ../src/httpd_write_content.py:40 ../src/qemu_blk_image.py:45
#: ../src/samba_share.py:45 ../src/swapfile.py:46 ../src/xen_image.py:48
msgid "You need to change the label on '$FIX_TARGET_PATH'"
msgstr "您需要更改 '$FIX_TARGET_PATH' 中的标签"

#: ../src/kernel_modules.py:29
msgid ""
"\n"
"    Your system may be seriously compromised! $SOURCE_PATH tried to modify "
"kernel configuration.\n"
"    "
msgstr "\n"
"    您的系统可能被严重破坏！ $SOURCE_PATH 试图修改内核配置。\n"
"    "

#: ../src/kernel_modules.py:33
msgid ""
"\n"
"    SELinux has prevented $SOURCE from modifying $TARGET.  This denial \n"
"    indicates $SOURCE was trying to modify the way the kernel runs or to \n"
"    actually insert code into the kernel. All applications that need this \n"
"    access should have already had policy written for them.  If a "
"compromised \n"
"    application tries to modify the kernel this AVC will be generated. This "
"is a \n"
"    serious issue. Your system may very well be compromised.\n"
"    "
msgstr ""
"\n"
"    SELinux 已不允许 $SOURCE 修改 $TARGET。\n"
"    这个拒绝意味着 $SOURCE 曾试图修改内核运行的方式\n"
"    或者在内核这插入编码。所有需要这个访问\n"
"    的程序都应该在其中写入了策略。如果被破坏的\n"
"    程序试图修改内核就会生成\n"
"    这个 AVC。这是一个严重的问题，您的系统可能被严重破坏。\n"
"    "

#: ../src/kernel_modules.py:44 ../src/selinuxpolicy.py:44
msgid ""
"you do not think $SOURCE_BASE_PATH should try $ACCESS access on "
"$TARGET_BASE_PATH."
msgstr "您不认为 $SOURCE_BASE_PATH 应在 $TARGET_BASE_PATH 中尝试 $ACCESS 访问。"

#: ../src/kernel_modules.py:45 ../src/selinuxpolicy.py:45
msgid ""
"you may be under attack by a hacker, since confined applications should not "
"need this access."
msgstr "您可能受到黑客攻击，因为受限制的应用程序不应需要这个访问。"

#: ../src/leaks.py:27
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH access to a leaked $TARGET_PATH file "
"descriptor.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE 访问泄漏的文件描述符 $TARGET_PATH。\n"
"    "

#: ../src/leaks.py:31
msgid ""
"\n"
"    SELinux denied access requested by the $SOURCE command. It looks like "
"this is either a leaked descriptor or $SOURCE output was redirected to a "
"file it is not allowed to access.  Leaks usually can be ignored since "
"SELinux is just closing the leak and reporting the error.  The application "
"does not use the descriptor, so it will run properly.  If this is a "
"redirection, you will not get output in the $TARGET_PATH.  You should "
"generate a bugzilla on selinux-policy, and it will get routed to the "
"appropriate package.  You can safely ignore this avc.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 $SOURCE 命令的请求。看起来可能是描述符泄露，也可能是将 $SOURCE "
"输出重新指向允许访问的文件。泄露一般可忽略，因为 SELinux "
"关闭泄露并报告了这个错误。该程序不使用描述符，因此可正常运行。如果这是一个重新指向，您在 $TARGET_PATH 中就不会看到输出。您应该可以根据 "
"selinux-policy 生成一个 bugzilla，并被指向适当的软件包。您可以忽略这个 avc。\n"
"    "

#: ../src/leaks.py:35
msgid ""
"\n"
"    You can generate a local policy module to allow this\n"
"    access - see <a href=\"http://docs.fedoraproject.org/selinux-faq-fc5/"
"#id2961385\">FAQ</a>\n"
"    "
msgstr ""
"\n"
"    您可以创建一个本地策略模块来允许这个\n"
"    访问 - 请查看 <a href=\"http://docs.fedoraproject.org/selinux-faq-fc5/"
"#id2961385\">常见问题</a>\n"
"    "

#: ../src/leaks.py:42
msgid ""
"you want to ignore $SOURCE_BASE_PATH trying to $ACCESS access the "
"$TARGET_BASE_PATH $TARGET_CLASS, because you believe it should not need this "
"access."
msgstr ""
"您想要忽略 $SOURCE_BASE_PATH 尝试 $ACCESS 访问 $TARGET_BASE_PATH "
"$TARGET_CLASS，因为您确定它不应需要这个访问。"

#: ../src/leaks.py:43
msgid ""
"You should report this as a bug.  \n"
"You can generate a local policy module to dontaudit this access."
msgstr "您应该将这个问题作为 bug 报告。 \n"
"您可以创建本地策略模块不审核这个访问。"

#: ../src/leaks.py:44
msgid ""
"# grep $SOURCE_PATH /var/log/audit/audit.log | audit2allow -D -M mypol\n"
"# semodule -i mypol.pp"
msgstr ""
"# grep $SOURCE_PATH /var/log/audit/audit.log | audit2allow -D -M mypol\n"
"# semodule -i mypol.pp"

#: ../src/mmap_zero.py:29
msgid ""
"\n"
"    Your system may be seriously compromised! $SOURCE_PATH attempted to mmap "
"low kernel memory.\n"
"    "
msgstr "\n"
"    您的系统可能被严重破坏！ $SOURCE_PATH 试图mmap低内核内存。\n"
"    "

#: ../src/mmap_zero.py:33
msgid ""
"\n"
"    SELinux has denied the $SOURCE the ability to mmap low area of the "
"kernel \n"
"    address space.  The ability to mmap a low area of the address space, as \n"
"    configured by /proc/sys/kernel/mmap_min_addr.  Preventing such mappings \n"
"    helps protect against exploiting null deref bugs in the kernel. All \n"
"    applications that need this access should have already had policy "
"written \n"
"    for them.  If a compromised application tries modify the kernel this AVC "
"\n"
"    would be generated. This is a serious issue. Your system may very well "
"be \n"
"    compromised.\n"
"    "
msgstr ""
"\n"
"    SELinux 不允许 $SOURCE mmap 内核地址的低区域。mmap 地址空间低区域的功能是由配置 /proc/sys/kernel/"
"mmap_min_addr 提供的。阻止这类映射可帮助保护内核空 deref bug "
"的问题。所有需要这个访问的程序都应该已被写入相应的策略。如果破坏的程序试图修改该内核则会生成这个 AVC。这是一个严重问题，您的系统可能被严重破坏。\n"
"    "

#: ../src/mmap_zero.py:46
msgid ""
"you do not think $SOURCE_PATH should need to mmap low memory in the kernel."
msgstr "您不认为 $SOURCE_PATH 应需要 mmap 内核中的低内存。"

#: ../src/mmap_zero.py:47
msgid "you may be under attack by a hacker, this is a very dangerous access."
msgstr "您可能受到黑客攻击，这是一个非常危险的访问。"

#: ../src/mounton.py:29
msgid ""
"\n"
"    SELinux prevented $SOURCE from mounting on the file or directory\n"
"    \"$TARGET_PATH\" (type \"$TARGET_TYPE\").\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止了 $SOURCE 挂载文件或者目录\n"
"    \"$TARGET_PATH\" (type \"$TARGET_TYPE\")。\n"
"    "

#: ../src/mounton.py:34
msgid ""
"\n"
"    SELinux prevented $SOURCE from mounting a filesystem on the file\n"
"    or directory \"$TARGET_PATH\" of type \"$TARGET_TYPE\". By default\n"
"    SELinux limits the mounting of filesystems to only some files or\n"
"    directories (those with types that have the mountpoint attribute). The\n"
"    type \"$TARGET_TYPE\" does not have this attribute. You can change the \n"
"    label of the file or directory.\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止了 $SOURCE 在类型为 \"$TARGET_TYPE\" 的文件\n"
"    或目录 \"$TARGET_PATH\" 中挂载文件系统。默认情况下 SELinux 限制\n"
"    文件系统只能挂载在一些文件或目录上（那些具有含挂载点属性类\n"
"    型的文件）。类型 \"$TARGET_TYPE\" 不具有这个属性。您可以改变该\n"
"    文件或目录的标签。\n"
"    "

#: ../src/mounton.py:43
msgid ""
"\n"
"    Changing the file_context to mnt_t will allow mount to mount the file "
"system:\n"
"    \"chcon -t mnt_t '$TARGET_PATH'.\"\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"mnt_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    将 file_context 改为 mnt_t 可允许 mount 挂载文件系统：\n"
"    \"chcon -t mnt_t '$TARGET_PATH'。\"\n"
"    您还必须更改系统中的默认文件上下文以便在完全重新标记时保留它们。\"semanage fcontext -a -t mnt_t "
"'$FIX_TARGET_PATH'\"\n"
"    "

#: ../src/mounton.py:48
msgid "you want to allow $SOURCE_BASE_PATH to mount on $TARGET_BASE_PATH."
msgstr "您想要允许 $SOURCE_BASE_PATH 挂载到 $TARGET_BASE_PATH。"

#: ../src/mounton.py:49
msgid "you must change the labeling on $TARGET_PATH."
msgstr "您必须在 $TARGET_PATH 中更改标记。"

#: ../src/mozplugger.py:31
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. It is not expected that this "
"access is required by $SOURCE and this access may signal an intrusion "
"attempt. It is also possible that the specific version or configuration of "
"the application is causing it to require additional access.  mozplugger and "
"spice-xpi run applications within mozilla-plugins that require access to the "
"desktop, that the mozilla_plugin lockdown will not allow, so either you need "
"to turn off the mozilla_plugin lockdown or not use these packages.\n"
"    "
msgstr ""

#: ../src/mozplugger.py:35
msgid ""
"\n"
"Either remove the mozplugger or spice-xpi package by executing 'yum remove "
"mozplugger spice-xpi' or turn off enforcement of SELinux over the Firefox "
"plugins. setsebool -P unconfined_mozilla_plugin_transition 0\n"
"    "
msgstr ""

#: ../src/mozplugger.py:43
msgid "you must turn off SELinux controls on the Firefox plugins."
msgstr "您必须关闭 SELinux 对于 FIrefox 插件的控制。"

#: ../src/mozplugger_remove.py:31
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. It is not\n"
"    expected that this access is required by $SOURCE and this access\n"
"    may signal an intrusion attempt. It is also possible that the specific\n"
"    version or configuration of the application is causing it to require\n"
"    additional access.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 $SOURCE 的访问请求。这不该是\n"
"    $SOURCE 所需要的访问请求故此这个请求\n"
"    可能代表一个入侵企图。 这也可能是特定\n"
"    版本或应用程序的配置导致其需要\n"
"    额外访问。\n"
"    "

#: ../src/mozplugger_remove.py:39
msgid ""
"\n"
"Either remove the mozplluger package by executing 'yum remove mozplugger'\n"
"Or turn off enforcement of SELinux over the Firefox plugins.\n"
"setsebool -P unconfined_mozilla_plugin_transition 0\n"
"    "
msgstr ""
"\n"
"您可以执行 'yum remove mozplugger' 移除 mozplluger 软件包 \n"
"后者在 Firefox 插件上关闭 SELinux 强制检查。\n"
"setsebool -P unconfined_mozilla_plugin_transition 0\n"
"    "

#: ../src/mozplugger_remove.py:44
msgid ""
"you want to to continue using SELinux Firefox plugin containment rather then "
"using mozplugger package"
msgstr "您若更想继续使用 SELinux Firefox 插件容器而不是 mozplugger 软件包"

#: ../src/mozplugger_remove.py:45
msgid "you must remove the mozplugger package."
msgstr "您必须移除 mozplugger 软件包。"

#: ../src/openvpn.py:35
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. $TARGET_PATH may\n"
"    be a mislabeled. openvpn is allowed to read content in home directory if "
"it \n"
"    is labeled correctly.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝 $SOURCE 请求的访问。$TARGET_PATH 可能\n"
"    是被错误标记了。如果正确表姐 openvpn ，则允许其读取主目录中的 \n"
"    内容。\n"
"    "

#: ../src/openvpn.py:41 ../src/sshd_root.py:42
msgid ""
"\n"
"    You can restore the default system context to this file by executing the\n"
"    restorecon command.  restorecon restore using restorecon -R /root/.ssh.\n"
"    "
msgstr ""
"\n"
"    您可以执行 restorecon 命令恢复这个文件的默认系统\n"
"    上下文。restorecon 使用 restorecon -R /root/.ssh 恢复。\n"
"    "

#: ../src/openvpn.py:48
msgid ""
"you want to mv $TARGET_BASE_PATH to standard location so that "
"$SOURCE_BASE_PATH can have $ACCESS access"
msgstr "您想要将 $TARGET_BASE_PATH 移动到标准位置，以便 $SOURCE_BASE_PATH 可拥有 $ACCESS 访问"

#: ../src/openvpn.py:50
msgid ""
"you want to modify the label on $TARGET_BASE_PATH so that $SOURCE_BASE_PATH "
"can have $ACCESS access on it"
msgstr "您想要修改 $TARGET_BASE_PATH 中的标签，以便 $SOURCE_BASE_PATH 可对其进行 $ACCESS 访问。"

#: ../src/openvpn.py:54
msgid "you must move the cert file to the ~/.cert directory"
msgstr "您必须将证书文件移动到 ~/.cert 目录中"

#: ../src/openvpn.py:56 ../src/sshd_root.py:47
msgid "you must fix the labels."
msgstr "您必须改正这个标签。"

#: ../src/public_content.py:31
msgid ""
"\n"
"    SELinux denied access to $TARGET_PATH requested by $SOURCE.\n"
"    $TARGET_PATH has a context used for sharing by a different program. If "
"you\n"
"    would like to share $TARGET_PATH from $SOURCE also, you need to\n"
"    change its file context to public_content_t.  If you did not intend to\n"
"    allow this access, this could signal an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 $SOURCE 请求的对 $TARGET_PATH 的访问。\n"
"    $TARGET_PATH 具有一个用于被不同程序共享的上下文。如果您想\n"
"    让 $SOURCE 也共享 $TARGET_PATH ，您需要将它的文件上下文改\n"
"    为 public_content_t。如果您没有打算进行这个访问，这可能是入侵尝试的信号。\n"
"    "

#: ../src/public_content.py:39
msgid ""
"\n"
"    You can alter the file context by executing chcon -t public_content_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"public_content_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    您可以执行 executing chcon -t public_content_t '$TARGET_PATH' 来改变文件上下文。\n"
"    您还必须在系统中更改默认文件上下文文件以便在完全重新标记后保留它们。\"semanage fcontext -a -t "
"public_content_t '$FIX_TARGET_PATH'\""

#: ../src/public_content.py:50
msgid "you want to treat $TARGET_BASE_PATH as public content"
msgstr "您想要将 $TARGET_BASE_PATH 视为公共内容"

#: ../src/public_content.py:51
msgid ""
"You need to change the label on $TARGET_BASE_PATH to public_content_t or "
"public_content_rw_t."
msgstr "您需要在 $TARGET_BASE_PATH 将标签改为 public_content_t 或 public_content_rw_t。"

#: ../src/qemu_blk_image.py:31
msgid ""
"\n"
"    SELinux denied qemu access to the block device $TARGET_PATH.\n"
"    If this is a virtualization image, it needs to be labeled with a "
"virtualization file context (virt_image_t). You can relabel $TARGET_PATH to "
"be virt_image_t using chcon.  You also need to execute semanage fcontext -a -"
"t virt_image_t '$FIX_TARGET_PATH' to add this\n"
"    new path to the system defaults. If you did not intend to use "
"$TARGET_PATH as a qemu\n"
"    image it could indicate either a bug or an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 qemu 访问 $TARGET_PATH。\n"
"    如果这是一个虚拟映像，它应当有一个虚拟文件上下文标签（virt_image_t）。您可以使用 chcon 将 $TARGET_PATH "
"重新标记为 virt_image_t。您还需要执行 semanage fcontext -a -t virt_image_t "
"'$FIX_TARGET_PATH' 将这个新路径添加到系统默认中。\n"
"   如果您没想要使用 $TARGET_PATH 作为 qemu 映像，那么这可能意味着一个 Bug 或是入侵尝试的信号。\n"
"    "

#: ../src/qemu_blk_image.py:38 ../src/qemu_file_image.py:41
msgid ""
"\n"
"    You can alter the file context by executing chcon -t virt_image_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"virt_image_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    您可以执行 chcon -t virt_image_t '$TARGET_PATH' 来更改文件上下文。\n"
"    您还必须在系统中更改默认文件上下文文件以便在完全重新标记后保留它们。\"semanage fcontext -a -t virt_image_t "
"'$FIX_TARGET_PATH'\""

#: ../src/qemu_blk_image.py:46
msgid ""
"# semanage fcontext -a -t virt_image_t '$FIX_TARGET_PATH'\n"
"# restorecon -v '$FIX_TARGET_PATH'"
msgstr ""
"# semanage fcontext -a -t virt_image_t '$FIX_TARGET_PATH'\n"
"# restorecon -v '$FIX_TARGET_PATH'"

#: ../src/qemu_file_image.py:31
msgid ""
"\n"
"    SELinux denied qemu access to $TARGET_PATH.\n"
"    If this is a virtualization image, it has to have a file context label "
"of\n"
"    virt_image_t. The system is setup to label image files in directory./var/"
"lib/libvirt/images\n"
"    correctly.  We recommend that you copy your image file to /var/lib/"
"libvirt/images.\n"
"    If you really want to have your qemu image files in the current "
"directory, you can relabel $TARGET_PATH to be virt_image_t using chcon.  You "
"also need to execute semanage fcontext -a -t virt_image_t '$FIX_TARGET_PATH' "
"to add this\n"
"    new path to the system defaults. If you did not intend to use "
"$TARGET_PATH as a qemu\n"
"    image it could indicate either a bug or an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 qemu 访问 $TARGET_PATH。\n"
"    如果这是一个虚拟映像，它应当有一个 virt_image_t 文件上下文标签。\n"
"    已经将该系统设置为将目录 ./var/lib/libvirt/images 中的映像文件标记为 virt_image_t。\n"
"    如果您确实希望将 qemu 映像保存在当前目录下，您可以使用 chcon 将 $TARGET_PATH 重新标记为 "
"virt_image_t。您还需要执行 semanage fcontext -a -t virt_image_t '$FIX_TARGET_PATH' "
"将这个新路径添加到系统默认中。如果您没想要使用 $TARGET_PATH 作为 qemu 映像，那么这可能意味着一个 Bug 或是入侵尝试的信号。\n"
"    "

#: ../src/qemu_file_image.py:48
msgid "$TARGET_BASE_PATH is a virtualization target"
msgstr "$TARGET_BASE_PATH 是一个虚拟化目标"

#: ../src/restorecon.py:48
msgid ""
"\n"
"    You can restore the default system context to this file by executing the\n"
"    restorecon command.  restorecon '$TARGET_PATH', if this file is a "
"directory,\n"
"    you can recursively restore using restorecon -R '$TARGET_PATH'.\n"
"    "
msgstr ""
"\n"
"    您可以执行 restorecon 命令为这个文件保存默认系统上下文。restorecon '$TARGET_PATH'，如果这个文件是一个目录，\n"
"    您可以使用 restorecon -R '$TARGET_PATH' 进行递归保存。"

#: ../src/restorecon.py:55
#, python-format
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. $TARGET_PATH may\n"
"    be a mislabeled.  $TARGET_PATH default SELinux type is\n"
"    <B>%s</B>, but its current type is <B>$TARGET_TYPE</B>. Changing\n"
"    this file back to the default type, may fix your problem.\n"
"    <p>\n"
"    File contexts can be assigned to a file in the following ways.\n"
"    <ul>\n"
"        <li>Files created in a directory receive the file context of the "
"parent directory by default.\n"
"        <li>The SELinux policy might override the default label inherited "
"from the parent directory by\n"
"            specifying a process running in context A which creates a file "
"in a directory labeled B\n"
"            will instead create the file with label C. An example of this "
"would be the dhcp client running\n"
"            with the dhclient_t type and creating a file in the directory /"
"etc. This file would normally\n"
"            receive the etc_t type due to parental inheritance but instead "
"the file\n"
"            is labeled with the net_conf_t type because the SELinux policy "
"specifies this.\n"
"        <li>Users can change the file context on a file using tools such as "
"chcon, or restorecon.\n"
"    </ul>\n"
"    This file could have been mislabeled either by user error, or if an "
"normally confined application\n"
"    was run under the wrong domain.\n"
"    <p> \n"
"    However, this might also indicate a bug in SELinux because the file "
"should not have been labeled\n"
"    with this type.\n"
"    <p>\n"
"    If you believe this is a bug, please file a bug report against this "
"package.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝 $SOURCE 的请求。$TARGET_PATH 可能被\n"
"    错误标记。$TARGET_PATH 默认 SELinux 类型为\n"
"    <B>%s</B>，但当前类型为 <B>$TARGET_TYPE</B>。将这个\n"
"    改回到默认类型可能解决您的问题。\n"
"    <p>\n"
"    可使用以下方法为文件分配文件上下文。\n"
"    <ul>\n"
"        <li>在某个目录中生成的文件默认接受其上级目录的文件上下文。\n"
"        <li>SELinux 策略可覆盖从上级目录中继承的默认标签，\n"
"            方法是指定在上下文 A 中运行的进程在标记为 B 的目录中生成文件，\n"
"            这样就生成标记为 C 的文件。具体示例为作为 dhclient_t 类型\n"
"            运行的 dhcp 客户端在目录 /etc 中生成文件。这个文件通常\n"
"            根据上级继承原则接受 the etc_t 类型，但是该文件被标记\n"
"            为 net_conf_t 类型，因为这是由 SELinux 策略指定的。\n"
"        <li>用户可使用类似 chcon 或 restorecon 的工具更改文件上下文。\n"
"    </ul>\n"
"    这个文件应该是被错误标记的，可能是用户失误，也可能是限制程序\n"
"    在错误的域中运行。\n"
"    <p> \n"
"    但这也可能代表是一个 SELinux 中的 bug，因为不应将该文件标记为\n"
"    这个类型。\n"
"    <p>\n"
"    如果您确定这是一个 bug，请根据这个软件包提交 bug 报告。\n"
"    "

#: ../src/restorecon.py:81
#, python-format
msgid "you want to fix the label. \n"
"$TARGET_PATH default label should be %s."
msgstr "您想要修复标签。 \n"
"$TARGET_PATH 默认标签应为 %s。"

#: ../src/restorecon.py:86 ../src/restorecon_source.py:65
msgid "you can run restorecon."
msgstr "您可以运行 restorecon。"

#: ../src/restorecon.py:94 ../src/restorecon_source.py:73
msgid "Restore\n"
"Context"
msgstr "恢复\n"
"上下文"

#: ../src/restorecon_source.py:39
msgid ""
"\n"
"    You can restore the default system context to this file by executing the\n"
"    restorecon command.  restorecon '$SOURCE_PATH'.\n"
"    "
msgstr "\n"
"    您要恢复该文件的默认文件上下文\n"
"使用 resotrecon 命令。restorecon '$SOURCE_PATH'。\n"
"    "

#: ../src/restorecon_source.py:45
#, python-format
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. $SOURCE_PATH may\n"
"    be a mislabeled.  $SOURCE_PATH default SELinux type is\n"
"    <B>%s</B>, but its current type is <B>$SOURCE_TYPE</B>. Changing\n"
"    this file back to the default type, may fix your problem.\n"
"    <p>\n"
"    This file could have been mislabeled either by user error, or if an "
"normally confined application\n"
"    was run under the wrong domain.\n"
"    <p> \n"
"    However, this might also indicate a bug in SELinux because the file "
"should not have been labeled\n"
"    with this type.\n"
"    <p>\n"
"    If you believe this is a bug, please file a bug report against this "
"package.\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止了来自 $SOURCE 的访问请求。$SOURCE_PATH 可能\n"
"    被错误标注了。$SOURCE_PATH 默认 SELinux 类型是\n"
"    <B>%s</B>，但它当前类型是 <B>$SOURCE_TYPE</B>。将文件\n"
"    恢复为默认类型，可能修复您的问题。\n"
"    <p>\n"
"    该文件可能由于用户操作，或者运行在错误域的正常受限程序\n"
"    被错误的标注了。\n"
"    <p> \n"
"    但是，这也可能代表一个 SELinux Bug，因为此文件\n"
"    不应该被标注为当前类型。\n"
"    <p>\n"
"    如果认为这是一个 Bug，请针对该软件包提交 Bug 报告。\n"
"    "

#: ../src/restorecon_source.py:60
#, python-format
msgid "you want to fix the label. \n"
"$SOURCE_PATH default label should be %s."
msgstr "您想要修复标签。 \n"
"$SOURCE_PATH 默认标签应为 %s。"

#: ../src/rsync_data.py:31
msgid ""
"\n"
"    SELinux denied rsync access to $TARGET_PATH.\n"
"    If this is a RSYNC repository it has to have a file context label of\n"
"    rsync_data_t. If you did not intend to use $TARGET_PATH as a rsync "
"repository\n"
"    it could indicate either a bug or it could signal a intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 rsync 访问 $TARGET_PATH 。\n"
"    如果这是一个 RSYNC 仓库，它必须有一个 rsync_data_t 上下文标签。如果\n"
"    您没有打算将 $TARGET_PATH 作为 rsync 仓库，这可能意味着一个 bug 或\n"
"    是入侵尝试的信号。\n"
"    "

#: ../src/rsync_data.py:38
msgid ""
"\n"
"    You can alter the file context by executing chcon -R -t rsync_data_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"rsync_data_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    您能够通过执行 chcon -R -t rsync_data_t '$TARGET_PATH' 更改文件上下文。\n"
"    您还必须在系统中更改默认文件上下文文件以便在完全重新标记后保留它们。\"semanage fcontext -a -t rsync_data_t "
"'$FIX_TARGET_PATH'\"\n"
"    "

#: ../src/rsync_data.py:45
msgid "$TARGET_BASE_PATH should be shared via the rsync daemon"
msgstr "应通过 rsync 守护进程共享 $TARGET_BASE_PATH"

#: ../src/rsync_data.py:46
msgid "You need to change the label on $TARGET_BASE_PATH"
msgstr "您需要在 $TARGET_BASE_PATH 中更改标签"

#: ../src/samba_share.py:27
msgid ""
"\n"
"    SELinux is preventing Samba ($SOURCE_PATH) \"$ACCESS\" access to "
"$TARGET_PATH.\n"
"    "
msgstr ""
"\n"
"    SELinux 正在阻止 Samba ($SOURCE_PATH) \"$ACCESS\" 访问设备 $TARGET_PATH。\n"
"    "

#: ../src/samba_share.py:31
msgid ""
"\n"
"    SELinux denied samba access to $TARGET_PATH.\n"
"    If you want to share this directory with samba it has to have a file "
"context label of\n"
"    samba_share_t. If you did not intend to use $TARGET_PATH as a samba "
"repository\n"
"    it could indicate either a bug or it could signal a intrusion attempt.\n"
"    Please refer to 'man samba_selinux' for more information on setting up "
"Samba and SELinux.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 samba 访问 $TARGET_PATH 。\n"
"   如果您想用 samba 共享这个目录，它必须有一个 samba_share_t 上下文标签。\n"
"如果您没有打算将 $TARGET_PATH 作为 samba 仓库，这意味着一个 Bug 或是入侵\n"
"尝试的信号。\n"
"请参考“man samba_selinux”来了解更多设置 Samba 和 SELinux 的信息。\n"
"    "

#: ../src/samba_share.py:39
msgid ""
"\n"
"    You can alter the file context by executing chcon -R -t samba_share_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"samba_share_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    您可以通过执行 chcon -R -t samba_share_t '$TARGET_PATH' 更改文件上下文。\n"
"    您还必须在系统中更改默认文件上下文文件以便在完全重新标记后保留它们。\"semanage fcontext -a -t "
"samba_share_t '$FIX_TARGET_PATH'\""

#: ../src/samba_share.py:53
#, python-format
msgid ""
"# semanage fcontext -a -t samba_share_t '$FIX_TARGET_PATH%s'\n"
"# restorecon %s -v '$FIX_TARGET_PATH'"
msgstr ""
"# semanage fcontext -a -t samba_share_t '$FIX_TARGET_PATH%s'\n"
"# restorecon %s -v '$FIX_TARGET_PATH'"

#: ../src/sandbox_connect.py:33
msgid ""
"\n"
"    SELinux has denied $SOURCE from connecting to a network port "
"$PORT_NUMBER within a sandbox.\n"
"    If $SOURCE should be allowed to connect on $PORT_NUMBER, you need to use "
"a different sandbox type like sandbox_web_t or sandbox_net_t.  sandbox -X -t "
"sandbox_net_t $SOURCE.\n"
"    \n"
"\n"
"If $SOURCE is not supposed\n"
"    to connect to $PORT_NUMBER, this could signal a intrusion attempt.\n"
"    "
msgstr ""

#: ../src/sandbox_connect.py:41
msgid ""
"\n"
"    If you want to allow $SOURCE to connect to $PORT_NUMBER, you can execute "
"\n"
"\n"
"    # sandbox -X -t sandbox_net_t $SOURCE\n"
"    "
msgstr ""
"\n"
"   如果您要允许 $SOURCE 连接到 $PORT_NUMBER，您可以执行\n"
"\n"
"    # sandbox -X -t sandbox_net_t $SOURCE\n"
"    "

#: ../src/sandbox_connect.py:47
msgid "you want to allow $SOURCE_PATH to connect to network port $PORT_NUMBER"
msgstr "您要允许 $SOURCE_PATH 连接至网络端口号 $PORT_NUMBER"

#: ../src/sandbox_connect.py:49
msgid ""
"you need to modify the sandbox type. sandbox_web_t or sandbox_net_t. \n"
"For example:\n"
"sandbox -X -t sandbox_net_t $SOURCE_PATH\n"
"Please read 'sandbox' man page for more details.\n"
msgstr ""
"您需要变更沙盒类型，即参数 sandbox_web_t 或 sandbox_net_t。\n"
"例如：\n"
"sandbox -X -t sandbox_net_t $SOURCE_PATH\n"
"请阅读 'sandbox' man 手册了解更多。\n"

#: ../src/selinuxpolicy.py:29
msgid "\n"
"    Your system may be seriously compromised!\n"
"    "
msgstr "\n"
"    您的系统可能被严重破坏！\n"
"    "

#: ../src/selinuxpolicy.py:33
msgid ""
"\n"
"    SELinux has prevented $SOURCE from modifying $TARGET.  This denial \n"
"    indicates $SOURCE was trying to modify the selinux policy configuration. "
"\n"
"    All applications that need this access should have already had policy \n"
"    written for them.  If a compromised application tries to modify the "
"SELinux\n"
"    policy this AVC will be generated. This is a serious issue. Your system \n"
"    may very well be compromised.\n"
"    "
msgstr ""
"\n"
"    SELinux 已阻止 $SOURCE 修改 $TARGET。这个拒绝表明 $SOURCE 曾试图修改 selinux "
"策略配置。所有需要这个访问的程序都应该已经有写入的策略。如果破坏的程序试图修改 SELinux 则会生成这个 "
"AVC。这是个严重问题。您的系统可能被严重破坏。\n"
"    "

#: ../src/setenforce.py:27
msgid "you did not directly cause this AVC through testing."
msgstr "您没有在测试中直接造成这个 AVC。"

#: ../src/setenforce.py:28
msgid "if you think that you might have been hacked"
msgstr "如果您认为您已被攻击"

#: ../src/setenforce.py:32
msgid ""
"\n"
"    Your system may be seriously compromised! $SOURCE_PATH tried to modify "
"SELinux enforcement.\n"
"    "
msgstr "\n"
"    您的系统可能被严重破坏！ $SOURCE_PATH 试图修改 SELinux enforcement.\n"
"    "

#: ../src/setenforce.py:36
msgid ""
"\n"
"    SELinux has prevented $SOURCE from writing to a file under /selinux.\n"
"    Files under /selinux control the way SELinux is configured.\n"
"    All programs that need to write to files under /selinux should have "
"already had policy\n"
"    written for them. If a compromised application tries to turn off SELinux\n"
"    this AVC will be generated. This is a serious issue. Your system may "
"very\n"
"    well be compromised.\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止 $SOURCE 写入 /selinux 中的文件。/selinux 中的文件控制配置 SELinux 的方法。所有需要在 /"
"selinux 中写入文件的程序都已经被写入了策略。如果破坏的程序试图关闭 SELiux 则会生成这个 AVC。这是个严重问题。您的系统可能被严重破坏。\n"
"    "

#: ../src/setenforce.py:48
msgid "you believe $SOURCE_PATH tried to disable SELinux."
msgstr "您确定 $SOURCE_PATH 曾尝试禁用 SELinux。"

#: ../src/setenforce.py:49
msgid ""
"you may be under attack by a hacker, since confined applications should "
"never need this access."
msgstr "您可能收到黑客攻击，因为限定程序从不需要这个访问。"

#: ../src/sshd_root.py:36
msgid ""
"\n"
"    SELinux denied access requested by $SOURCE. $TARGET_PATH may\n"
"    be a mislabeled. sshd is allowed to read content in /root/.ssh directory "
"if it \n"
"    is labeled correctly.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝 $SOURCE 请求的访问。$TARGET_PATH 可能是\n"
"    被错误标记了。如果正确标记，则可允许 sshd 读取 /root/.ssh 目录 \n"
"    中的内容。\n"
"    "

#: ../src/sshd_root.py:54
msgid "Restore Context"
msgstr "恢复上下文"

#: ../src/swapfile.py:27
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH \"$ACCESS\" to $TARGET_PATH.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH \"$ACCESS\"  $TARGET_PATH。\n"
"    "

#: ../src/swapfile.py:31
msgid ""
"\n"
"    SELinux denied $SOURCE access to $TARGET_PATH.\n"
"    If this is a swapfile it has to have a file context label of\n"
"    swapfile_t. If you did not intend to use\n"
"    $TARGET_PATH as a swapfile it probably indicates a bug, however it could "
"also\n"
"    signal a intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 $SOURCE 访问 $TARGET_PATH。如果这是一个交换文\n"
"    件，它应当有一个 swapfile_t 文件上下文标签。如果您没有打算使用 $TARGET_PATH 做\n"
"    交换文件，这很可能意味着一个 Bug，但这也可能是入侵尝试的信号。\n"
"    "

#: ../src/swapfile.py:39
msgid ""
"\n"
"    You can alter the file context by executing chcon -t swapfile_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"swapfile_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    您可以执行 executing chcon -t swapfile_t '$TARGET_PATH' 更改文件上下文。\n"
"    您还必须在系统中更改默认文件上下文文件以便在完全重新标记后保留它们。\"semanage fcontext -a -t swapfile_t "
"'$FIX_TARGET_PATH'\""

#: ../src/sys_module.py:28
msgid ""
"you do not believe your $SOURCE_PATH should be modifying the kernel, by "
"loading kernel modules"
msgstr "您不认为您的 $SOURCE_PATH 应通过载入内核模块修改内核"

#: ../src/sys_module.py:29
msgid "You might have been hacked."
msgstr "您肯定被攻击了。"

#: ../src/sys_module.py:33
msgid ""
"\n"
"    Your system may be seriously compromised! $SOURCE_PATH tried to load a "
"kernel module.\n"
"    "
msgstr "\n"
"    您的系统可能被严重破坏！ $SOURCE_PATH试图装载一个内核模块。\n"
"    "

#: ../src/sys_module.py:37
msgid ""
"\n"
"    SELinux has prevented $SOURCE from loading a kernel module.\n"
"    All confined programs that need to load kernel modules should have "
"already had policy\n"
"    written for them. If a compromised application \n"
"    tries to modify the kernel this AVC will be generated. This is a serious "
"\n"
"    issue. Your system may very well be compromised.\n"
"    "
msgstr ""
"\n"
"    SELinux 阻止 $SOURCE 载入内核模块。所有需要载入内核模块的被限制的程序应该已经写入了策略。如果破坏的程序要修改内核则会生成这个 "
"AVC。这是个严重问题。您的系统可能被严重破坏。\n"
"    "

#: ../src/sys_module.py:46
msgid ""
"you do not believe that $SOURCE_PATH should be attempting to modify the "
"kernel by loading a kernel module."
msgstr "您不认为 $SOURCE_PATH 应尝试通过载入内核模块修改内核。"

#: ../src/sys_module.py:47
msgid "A process might be attempting to hack into your system."
msgstr "应该是某个进程正在尝试入侵您的系统。"

#: ../src/sys_resource.py:28
msgid ""
"\n"
"    SELinux is preventing $SOURCE_PATH the \"sys_resource\" capability. \n"
"    "
msgstr "\n"
"    SELinux 正在阻止 $SOURCE_PATH 的 \"sys_resource\" 功能。\n"
"    "

#: ../src/sys_resource.py:32
msgid ""
"\n"
"    Confined domains should not require \"sys_resource\". This usually means "
"that     your system is running out some system resource like disk space, "
"memory, quota etc. Please clear up the disk and this\n"
"    AVC message should go away. If this AVC continues after you clear up the "
"disk space, please report this as a bug. \n"
"    "
msgstr ""
"\n"
"限制域不应该需要 \"sys_resource\"。这通常意味着您没有足够的系统资源，比如磁盘空间、内存、配额等等。请清理该磁盘，\n"
"AVC 信息就应该消失。如果您清理磁盘空间后仍存在 AVC，请将其作为 bug 报告。\n"
"    "

#: ../src/sys_resource.py:39
msgid ""
"you do not want processes to require capabilities to use up all the system "
"resources on your system;"
msgstr "您不想让进程要求容量耗尽您系统中的所有资源；"

#: ../src/sys_resource.py:40
msgid ""
"you need to diagnose why your system is running out of system resources and "
"fix the problem.  \n"
"\n"
"According to /usr/include/linux/capability.h, sys_resource is required to:\n"
"\n"
"/* Override resource limits. Set resource limits. */\n"
"/* Override quota limits. */\n"
"/* Override reserved space on ext2 filesystem */\n"
"/* Modify data journaling mode on ext3 filesystem (uses journaling\n"
"   resources) */\n"
"/* NOTE: ext2 honors fsuid when checking for resource overrides, so\n"
"   you can override using fsuid too */\n"
"/* Override size restrictions on IPC message queues */\n"
"/* Allow more than 64hz interrupts from the real-time clock */\n"
"/* Override max number of consoles on console allocation */\n"
"/* Override max number of keymaps */\n"
"/* Override resource limits. Set resource limits. */\n"
"/* Override quota limits. */\n"
"/* Override reserved space on ext2 filesystem */\n"
"/* Modify data journaling mode on ext3 filesystem (uses journaling\n"
"   resources) */\n"
"/* NOTE: ext2 honors fsuid when checking for resource overrides, so\n"
"   you can override using fsuid too */\n"
"/* Override size restrictions on IPC message queues */\n"
"/* Allow more than 64hz interrupts from the real-time clock */\n"
"/* Override max number of consoles on console allocation */\n"
"/* Override max number of keymaps */\n"
"/* Override resource limits. Set resource limits. */\n"
"/* Override quota limits. */\n"
"/* Override reserved space on ext2 filesystem */\n"
"/* Modify data journaling mode on ext3 filesystem (uses journaling\n"
"   resources) */\n"
"/* NOTE: ext2 honors fsuid when checking for resource overrides, so\n"
"   you can override using fsuid too */\n"
"/* Override size restrictions on IPC message queues */\n"
"/* Allow more than 64hz interrupts from the real-time clock */\n"
"/* Override max number of consoles on console allocation */\n"
"/* Override max number of keymaps */\n"
msgstr ""
"您需要判断为什么您的系统已耗尽资源并修复该问题。  \n"
"\n"
"根据 /usr/include/linux/capability.h，以下动作需要 sys_resource：\n"
"\n"
"/* Override resource limits. Set resource limits. */\n"
"/* Override quota limits. */\n"
"/* Override reserved space on ext2 filesystem */\n"
"/* Modify data journaling mode on ext3 filesystem (uses journaling\n"
"   resources) */\n"
"/* NOTE: ext2 honors fsuid when checking for resource overrides, so\n"
"   you can override using fsuid too */\n"
"/* Override size restrictions on IPC message queues */\n"
"/* Allow more than 64hz interrupts from the real-time clock */\n"
"/* Override max number of consoles on console allocation */\n"
"/* Override max number of keymaps */\n"
"/* Override resource limits. Set resource limits. */\n"
"/* Override quota limits. */\n"
"/* Override reserved space on ext2 filesystem */\n"
"/* Modify data journaling mode on ext3 filesystem (uses journaling\n"
"   resources) */\n"
"/* NOTE: ext2 honors fsuid when checking for resource overrides, so\n"
"   you can override using fsuid too */\n"
"/* Override size restrictions on IPC message queues */\n"
"/* Allow more than 64hz interrupts from the real-time clock */\n"
"/* Override max number of consoles on console allocation */\n"
"/* Override max number of keymaps */\n"
"/* Override resource limits. Set resource limits. */\n"
"/* Override quota limits. */\n"
"/* Override reserved space on ext2 filesystem */\n"
"/* Modify data journaling mode on ext3 filesystem (uses journaling\n"
"   resources) */\n"
"/* NOTE: ext2 honors fsuid when checking for resource overrides, so\n"
"   you can override using fsuid too */\n"
"/* Override size restrictions on IPC message queues */\n"
"/* Allow more than 64hz interrupts from the real-time clock */\n"
"/* Override max number of consoles on console allocation */\n"
"/* Override max number of keymaps */\n"

#: ../src/vbetool.py:30
msgid ""
"\n"
"    SELinux has prevented vbetool from performing an unsafe memory operation."
"\n"
"    "
msgstr "\n"
"    SELinux 阻止了 vbetool 执行一项不安全的内存操作。\n"
"    "

#: ../src/vbetool.py:34
msgid ""
"\n"
"SELinux denied an operation requested by $SOURCE, a program used\n"
"to alter video hardware state.  This program is known to use\n"
"an unsafe operation on system memory but so are a number of\n"
"malware/exploit programs which masquerade as vbetool.  This tool is used to \n"
"reset video state when a machine resumes from a suspend.  If your machine \n"
"is not resuming properly your only choice is to allow this\n"
"operation and reduce your system security against such malware.\n"
"\n"
"    "
msgstr ""
"\n"
"SELinux 阻止了由 $SOURCE 请求的一次操作，它是用于改变视频硬件状态的程序。已知此程序对系统内存采用不安全的操作，但是大量伪装成 "
"vbetool "
"的恶意／溢出程序也是如此。此工具用于当机器从挂起状态中恢复工作时重置视频状态。如果您的机器没有很好地恢复的话，您唯一的选择是允许此操作并降低您系统面对此类恶意软件的安全度。\n"
"\n"
"    "

#: ../src/vbetool.py:45 ../src/wine.py:56
msgid ""
"\n"
"If you decide to continue to run the program in question you will need\n"
"to allow this operation.  This can be done on the command line by\n"
"executing:\n"
"\n"
"# setsebool -P mmap_low_allowed 1\n"
msgstr ""
"\n"
"如果您想继续运行正在考虑的程序，您必须允许此操作。要允许就在命令行上执行：\n"
"\n"
"# setsebool -P mmap_low_allowed 1\n"

#: ../src/vbetool.py:55
msgid ""
"you want to ignore this AVC because it is dangerous and your machine seems "
"to be working correctly."
msgstr "您想要忽略这个 AVC，因为它很危险，而且您的机器目前正常工作。"

#: ../src/vbetool.py:56
msgid ""
"you must tell SELinux about this by enabling the vbetool_mmap_zero_ignore "
"boolean."
msgstr "您必须启用 vbetool_mmap_zero_ignore 布尔告知 SELinux 这个情况。"

#: ../src/vbetool.py:62 ../src/wine.py:73
msgid "Turn off memory protection"
msgstr "关闭内存保护"

#: ../src/wine.py:31
msgid ""
"\n"
"    SELinux has prevented wine from performing an unsafe memory operation.\n"
"    "
msgstr "\n"
"    SELinux 阻止了 wine 执行一项不安全的内存操作。\n"
"    "

#: ../src/wine.py:35
msgid ""
"\n"
"SELinux denied an operation requested by wine-preloader, a program used\n"
"to run Windows applications under Linux.  This program is known to use\n"
"an unsafe operation on system memory but so are a number of\n"
"malware/exploit programs which masquerade as wine.  If you were\n"
"attempting to run a Windows program your only choices are to allow this\n"
"operation and reduce your system security against such malware or to\n"
"refrain from running Windows applications under Linux.  If you were not\n"
"attempting to run a Windows application this indicates you are likely\n"
"being attacked by some for of malware or program trying to exploit your\n"
"system for nefarious purposes.\n"
"\n"
"Please refer to \n"
"\n"
"http://wiki.winehq.org/PreloaderPageZeroProblem\n"
"\n"
"Which outlines the other problems wine encounters due to its unsafe use\n"
"of memory and solutions to those problems.\n"
"\n"
"    "
msgstr ""
"\n"
"SELinux阻止了一项由 wine-preloader 请求的操作，它是用来在Linux下运行 Windows\n"
"应用程序的程序。已知此程序会对系统内存采用不安全的操作，但大量伪装成 wine 的恶意／\n"
"溢出程序也是如此。如果您曾尝试运行 Windows 程序，您只有选择允许此操作并降低您的\n"
"系统面对此类恶意软件时的安全度，或避免在Linux下运行 Ｗindows 应用程序。如果您不曾\n"
"尝试运行Windows 应用程序，这说明您很可能被一些恶意软件或为了不法目的尝试剥削您系\n"
"统的程序的攻击。\n"
"\n"
"请参考：\n"
"\n"
"http://wiki.winehq.org/PreloaderPageZeroProblem\n"
"\n"
"它概述了 wine 因其不安全的内存使用而遇到的其他问题以及解决方案。"

#: ../src/wine.py:66
msgid ""
"you want to ignore this AVC because it is dangerous and your wine "
"applications are working correctly."
msgstr "您想要忽略这个 AVC，因为它台危险，且您的 wine 程序目前正常。"

#: ../src/wine.py:67
msgid ""
"you must tell SELinux about this by enabling the wine_mmap_zero_ignore "
"boolean."
msgstr "您必须通过启用 wine_mmap_zero_ignore 告知 SELinux 这个情况。"

#: ../src/xen_image.py:27
msgid ""
"\n"
"    SELinux is preventing xen ($SOURCE_PATH) \"$ACCESS\" access to "
"$TARGET_PATH.\n"
"    "
msgstr "\n"
"    SELinux 正在阻止xen ($SOURCE_PATH) \"$ACCESS\" 访问设备 $TARGET_PATH。\n"
"    "

#: ../src/xen_image.py:31
msgid ""
"\n"
"    SELinux denied xen access to $TARGET_PATH.\n"
"    If this is a XEN image, it has to have a file context label of\n"
"    xen_image_t. The system is setup to label image files in directory /var/"
"lib/xen/images\n"
"    correctly.  We recommend that you copy your image file to /var/lib/xen/"
"images.\n"
"    If you really want to have your xen image files in the current "
"directory, you can relabel $TARGET_PATH to be xen_image_t using chcon.  You "
"also need to execute semanage fcontext -a -t xen_image_t '$FIX_TARGET_PATH' "
"to add this\n"
"    new path to the system defaults. If you did not intend to use "
"$TARGET_PATH as a xen\n"
"    image it could indicate either a bug or an intrusion attempt.\n"
"    "
msgstr ""
"\n"
"    SELinux 拒绝了 xen 访问 $TARGET_PATH。\n"
"    如果这是一个 XEN 映像，它应当有一个 xen_image_t 文件上下文标签。\n"
"    已经将该系统设置为在目录 /var/lib/xen/images 中标记映像文件\n"
"    如果您确实希望将 xen 映像保存在当前目录下，您可以使用 chcon 将 $TARGET_PATH 重新标记为 "
"xen_image_t。您还需要执行 semanage fcontext -a -t xen_image_t '$FIX_TARGET_PATH' "
"将这个新路径添加到系统默认中。如果您没想要使用 $TARGET_PATH 作为 xen 映像，那么这可能意味着一个 Bug 或是入侵尝试的信号。\n"
"    "

#: ../src/xen_image.py:41
msgid ""
"\n"
"    You can alter the file context by executing chcon -t xen_image_t "
"'$TARGET_PATH'\n"
"    You must also change the default file context files on the system in "
"order to preserve them even on a full relabel.  \"semanage fcontext -a -t "
"xen_image_t '$FIX_TARGET_PATH'\"\n"
"    "
msgstr ""
"\n"
"    您可以执行 chcon -t xen_image_t '$TARGET_PATH' 来更改文件上下文。\n"
"    您还必须在系统中更改默认文件上下文文件以便在完全重新标记后保留它们。\"semanage fcontext -a -t xen_image_t "
"'$FIX_TARGET_PATH'\""
